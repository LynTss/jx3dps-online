{"version":3,"file":"static/js/7034.085b71d7.js","mappings":"0LAQMA,EAAwB,CAAC,EAMzB,SAAUC,EAAUC,GAExB,OAAOF,EAAWE,EAAKC,gBAAkBC,EAAOF,EACjD,CAOK,SAAUG,EAAeH,EAAcI,GAC3CN,EAAWE,EAAKC,eAAiBG,CAClC,C,0ICjBKC,EAAkB,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GA8EjD,SAASC,EAAOC,EAAiBC,EAAsBC,GAC7C,IAKJC,EALIC,EAAqBH,EAAS,UAEtC,GAAIC,EAAUE,EAFeH,EAAS,OAEHA,EAAUI,QAC3C,OAAO,EAGT,IAAMC,EAAWL,EAAUK,SACrBC,EAASN,EAAUM,OACnBV,GAASL,EAAAA,EAAAA,GAAUe,GAIzB,GADAL,EAAUA,EAAUE,EAAYH,EAAUO,MACtCP,EAAUQ,OAGZN,EAAQN,EADRM,EAASD,EAAUI,EAAYA,OAE1B,CAEL,MADAH,EAAQD,EAAUI,GACN,GAUV,OALIL,EAAUS,QACZV,EAAMW,KAAKV,EAAUS,QAAQ,IAE7BV,EAAMW,KAAKV,EAAUW,UAEhB,EARPT,EAAQN,EAAOM,EAUlB,CACD,GAAIF,EAAUS,QAAS,CACrB,IAAMG,EAAQZ,EAAUS,QAAQP,GAChCH,EAAMW,KAAKE,EACZ,MAxGH,SAAiBb,EAAiBC,EAAsBE,GACtD,IAAMW,EAAS,CAAC,EACRC,EAAuBd,EAAS,UAArBW,EAAYX,EAAS,QACxC,IAAID,EAAMgB,UAAV,CAGA,IAAIC,ECtB0BC,EDuB9B,IAAK,IAAMC,KAAKP,EACd,KAAKQ,EAAAA,EAAAA,IAAQL,EAAUI,GAAIP,EAAQO,IACjC,GAAU,SAANA,EAAc,CAChB,IAAIE,EAAST,EAAQO,GACjBG,EAAWP,EAAUI,GACrBE,EAAOE,OAASD,EAASC,QAC3BF,EAASG,EAAAA,gBAAyBZ,EAAQO,IAC1CG,EAAWE,EAAAA,gBAAyBT,EAAUI,IAC9CG,EAAWE,EAAAA,eAAwBF,EAAUD,GAC7CC,EAAWE,EAAAA,WAAoBF,EAAUD,GACzCpB,EAAUc,UAAUU,KAAOH,EAC3BrB,EAAUW,QAAQa,KAAOJ,GACfpB,EAAUyB,gBACpBL,EAASG,EAAAA,gBAAyBZ,EAAQO,IAC1CG,EAAWE,EAAAA,gBAAyBT,EAAUI,IAC9CG,EAAWE,EAAAA,WAAoBF,EAAUD,GACzCpB,EAAUc,UAAUU,KAAOH,EAC3BrB,EAAUW,QAAQa,KAAOJ,EACzBpB,EAAUyB,eAAgB,GAE5BZ,EAAOK,GAAK,GACZ,IAAK,IAAIQ,EAAI,EAAGA,EAAIN,EAAOE,OAAQI,IAAK,CAItC,IAHA,IAAMC,EAAcP,EAAOM,GACrBE,EAAgBP,EAASK,GACzBG,EAAa,GACVC,EAAI,EAAGA,EAAIH,EAAYL,OAAQQ,KAClCC,EAAAA,EAAAA,IAASJ,EAAYG,KAAOF,IAAiBG,EAAAA,EAAAA,IAASH,EAAcE,KACtEd,GAASgB,EAAAA,EAAAA,GAAYJ,EAAcE,GAAIH,EAAYG,IACnDD,EAAWI,KAAKjB,EAAOd,KAEvB2B,EAAWI,KAAKN,EAAYG,IAGhCjB,EAAOK,GAAGe,KAAKJ,EAChB,CACF,MAAM,GAAU,WAANX,EAAgB,CAKzB,IACMgB,GADWC,EAAAA,EAAAA,GAAiBrB,EAAUI,IAAMrB,EAAiBc,EAAQO,IAAMrB,EAC3DuC,CAASlC,GAC/BW,EAAOK,GAAKgB,CACb,KCpE8B,CAAC,OAAQ,SAAU,YAAa,eAAeG,SDoEvDnB,KClEGD,EDkEmBN,EAAQO,GClEnB,uBAAuBoB,KAAKrB,IDmE5DJ,EAAOK,GAAKP,EAAQO,IACVqB,EAAAA,EAAAA,IAAW5B,EAAQO,MAE7BF,GAASgB,EAAAA,EAAAA,GAAYlB,EAAUI,GAAIP,EAAQO,IAC3CL,EAAOK,GAAKF,EAAOd,IAIzBH,EAAMW,KAAKG,EAtDV,CAuDF,CA6CG2B,CAAQzC,EAAOC,EAAWE,GAE5B,OAAO,CACR,CAED,IA6HA,EA7HA,WA0BE,WAAYuC,GAhBZ,KAAAC,UAAwB,GAKxB,KAAAC,QAAkB,EAKlB,KAAAC,MAAuB,KAOrBC,KAAKJ,OAASA,CACf,CA+FH,OA1FEK,EAAAA,UAAAA,UAAAA,WAAA,IAEM/C,EACAgD,EACA/C,EAJN,OAKE6C,KAAKD,MAAQI,EAAAA,IAAc,SAAC/C,GAE1B,GADAgD,EAAKN,QAAU1C,EACXgD,EAAKP,UAAUpB,OAAS,EAAG,CAC7B,IAAK,IAAII,EAAIuB,EAAKP,UAAUpB,OAAS,EAAGI,GAAK,EAAGA,IAE9C,IADA3B,EAAQkD,EAAKP,UAAUhB,IACbX,UAERkC,EAAKC,eAAexB,OAFtB,CAKA,IAAK3B,EAAMoD,kBAET,IAAK,IAAIrB,GADTiB,EAAahD,EAAMqD,IAAI,eACC9B,OAAS,EAAGQ,GAAK,EAAGA,IAC1C9B,EAAY+C,EAAWjB,GACVhC,EAAOC,EAAOC,EAAWC,KAEpC8C,EAAWM,OAAOvB,EAAG,IACR,EACT9B,EAAUsD,UACZtD,EAAUsD,YAKQ,IAAtBP,EAAWzB,QACb2B,EAAKC,eAAexB,EAhBrB,CAmBcuB,EAAKR,OAAOW,IAAI,aAG/BH,EAAKR,OAAOc,MAEf,CACF,GACF,EAKDT,EAAAA,UAAAA,YAAAA,SAAY/C,GACV8C,KAAKH,UAAUT,KAAKlC,EACrB,EAKD+C,EAAAA,UAAAA,eAAAA,SAAeU,GACbX,KAAKH,UAAUW,OAAOG,EAAO,EAC9B,EAKDV,EAAAA,UAAAA,YAAAA,WACE,QAASD,KAAKH,UAAUpB,MACzB,EAKDwB,EAAAA,UAAAA,KAAAA,WACMD,KAAKD,OACPC,KAAKD,MAAMa,MAEd,EAMDX,EAAAA,UAAAA,kBAAAA,SAAkBY,QAAA,IAAAA,IAAAA,GAAQ,GACxBb,KAAKH,UAAUiB,SAAQ,SAACC,GACtBA,EAASC,YAAYH,EACtB,IACDb,KAAKH,UAAY,GACjBG,KAAKJ,OAAOc,MACb,EAKDT,EAAAA,UAAAA,QAAAA,WACE,OAAOD,KAAKF,OACb,EACH,CAAC,CA3HD,E,4FE7HA,IAAMmB,EAAgC,IAAIC,IAOpC,SAAUC,EAASxE,EAAcyE,GACrCH,EAAMI,IAAI1E,EAAMyE,EACjB,CAMK,SAAUE,EAAU3E,GACxB,OAAOsE,EAAMV,IAAI5D,EAClB,CCjBa,WAAWO,GACvB,IAAMa,EAAQb,EAAMW,OAEpB,MAAO,CACL0D,EAF8BxD,EAAK,EAGnCyD,EAH8BzD,EAAK,EAInC0D,MAJ8B1D,EAAK,MAKnC2D,OAL8B3D,EAAK,OAOtC,CCTa,WAAWb,GACjB,MAAcA,EAAMW,OAAlB0D,EAAC,IAAEC,EAAC,IAAEG,EAAC,IACf,MAAO,CACLJ,EAAGA,EAAII,EACPH,EAAGA,EAAIG,EACPF,MAAW,EAAJE,EACPD,OAAY,EAAJC,EAEX,C,eCRK,SAAUC,EAAUC,EAAOC,GAC/B,OAAKD,GAAUC,EAGR,CACLC,KAAMC,KAAKC,IAAIJ,EAAME,KAAMD,EAAMC,MACjCG,KAAMF,KAAKC,IAAIJ,EAAMK,KAAMJ,EAAMI,MACjCC,KAAMH,KAAKI,IAAIP,EAAMM,KAAML,EAAMK,MACjCE,KAAML,KAAKI,IAAIP,EAAMQ,KAAMP,EAAMO,OAN1BR,GAASC,CAQnB,CAGK,SAAUQ,EAAepF,EAAeqF,GAC5C,IAAMC,EAAkBtF,EAAMqD,IAAI,mBAC5BkC,EAAgBvF,EAAMqD,IAAI,iBAWhC,OARIiC,IAEFD,EAAOX,EAAUW,EADAC,EAAgBE,kBAG/BD,IAEFF,EAAOX,EAAUW,EADFE,EAAcC,kBAGxBH,CACR,C,yCC8DD,SAASI,EAA6BC,EAASC,GACrC,IAAAC,EAAsCF,EAAO,SAAnCG,EAA4BH,EAAO,aAArBI,EAAcJ,EAAO,UAC/CK,EAAgBjB,KAAKkB,IAAIH,EAAa,GAAKD,EAAS,GAAI,GAAKd,KAAKkB,IAAIH,EAAa,GAAKD,EAAS,GAAI,GACrGK,EAAiBnB,KAAKkB,IAAIH,EAAa,GAAKC,EAAU,GAAI,GAAKhB,KAAKkB,IAAIH,EAAa,GAAKC,EAAU,GAAI,GACxGI,EAAapB,KAAKkB,IAAIJ,EAAS,GAAKE,EAAU,GAAI,GAAKhB,KAAKkB,IAAIJ,EAAS,GAAKE,EAAU,GAAI,GAE5FK,EAAerB,KAAKsB,MACvBL,EAAgBE,EAAiBC,IAAe,EAAIpB,KAAKuB,KAAKN,GAAiBjB,KAAKuB,KAAKJ,KAI5F,IAAKE,GAA2C,IAA3BrB,KAAKwB,IAAIH,KAAuBI,EAAAA,EAAAA,IAAcJ,EAAc,GAC/E,MAAO,CACLK,OAAQ,EACRC,OAAQ,GAGZ,IAAIC,EAAS5B,KAAK6B,IAAI7B,KAAK8B,MAAMd,EAAU,GAAKD,EAAa,GAAIC,EAAU,GAAKD,EAAa,KACzFgB,EAAS/B,KAAK6B,IAAI7B,KAAK8B,MAAMd,EAAU,GAAKD,EAAa,GAAIC,EAAU,GAAKD,EAAa,KAc7F,OAZAa,EAASA,EAAS5B,KAAKgC,GAAK,EAAIhC,KAAKgC,GAAKJ,EAASA,EACnDG,EAASA,EAAS/B,KAAKgC,GAAK,EAAIhC,KAAKgC,GAAKD,EAASA,EAGrC,CAEZL,OACE1B,KAAKiC,IAAIZ,EAAe,EAAIO,IAAYf,EAAY,GAAM,EAAIb,KAAKwB,IAAIH,EAAe,KAAOR,EAAY,GAAK,EAEhHc,OACE3B,KAAKiC,IAAIF,EAASV,EAAe,IAAOR,EAAY,GAAM,EAAIb,KAAKwB,IAAIH,EAAe,KAAOR,EAAY,GAAK,EAGnH,CCnHD1B,EAAS,OAAQ+C,GACjB/C,EAAS,QAAS+C,GAClB/C,EAAS,SAAUgD,GACnBhD,EAAS,SAAUgD,GACnBhD,EAAS,YCTK,SAAWjE,GAKvB,IAJA,IACQkH,EADMlH,EAAMW,OACI,OAClBwG,EAAO,GACPC,EAAO,GACJzF,EAAI,EAAGA,EAAIuF,EAAO3F,OAAQI,IAAK,CACtC,IAAM0F,EAAQH,EAAOvF,GACrBwF,EAAKjF,KAAKmF,EAAM,IAChBD,EAAKlF,KAAKmF,EAAM,GACjB,CACK,MAA0BC,EAAAA,GAAAA,eAAoBH,EAAMC,GAAlD/C,EAAC,IAAEC,EAAC,IACRe,EAAO,CACTR,KAAMR,EACNW,KAAMV,EACNW,KAAMZ,EAJW,QAKjBc,KAAMb,EALmB,UAQ3B,MAAO,CACLD,GAFFgB,EAAOD,EAAepF,EAAOqF,IAEnBR,KACRP,EAAGe,EAAKL,KACRT,MAAOc,EAAKJ,KAAOI,EAAKR,KACxBL,OAAQa,EAAKF,KAAOE,EAAKL,KAE5B,IDdDf,EAAS,WEXK,SAAWjE,GAKvB,IAJA,IACQkH,EADMlH,EAAMW,OACI,OAClBwG,EAAO,GACPC,EAAO,GACJzF,EAAI,EAAGA,EAAIuF,EAAO3F,OAAQI,IAAK,CACtC,IAAM0F,EAAQH,EAAOvF,GACrBwF,EAAKjF,KAAKmF,EAAM,IAChBD,EAAKlF,KAAKmF,EAAM,GACjB,CACD,OAAOC,EAAAA,GAAAA,eAAoBH,EAAMC,EAClC,IFCDnD,EAAS,QGZK,SAAWjE,GACvB,IAAMa,EAAQb,EAAMW,OACZ0D,EAAqCxD,EAAK,EAAvCyD,EAAkCzD,EAAK,EAApC0G,EAA+B1G,EAAK,KAA9B2G,EAAyB3G,EAAK,SAApB4G,EAAe5G,EAAK,WAC9C6G,EAAO7G,EAAM6G,KACZA,IAEHA,GAAOC,EAAAA,EAAAA,IAAa9G,IAEtB,IACIwE,EADEd,GAAQqD,EAAAA,EAAAA,IAAaL,EAAMG,GAEjC,GAAKnD,EAQE,CACG,IAAAsD,EAA4BhH,EAAK,UAAtBiH,EAAiBjH,EAAK,aACnC2D,GAASuD,EAAAA,EAAAA,IAAcR,EAAMC,EAAUC,GAEvCJ,EAAQ,CACZhD,EAAC,EACDC,EAAGA,EAAIE,GAELqD,IACgB,QAAdA,GAAqC,UAAdA,EACzBR,EAAMhD,GAAKE,EACY,WAAdsD,IACTR,EAAMhD,GAAKE,EAAQ,IAGnBuD,IACmB,QAAjBA,EACFT,EAAM/C,GAAKE,EACe,WAAjBsD,IACTT,EAAM/C,GAAKE,EAAS,IAIxBa,EAAO,CACLhB,EAAGgD,EAAMhD,EACTC,EAAG+C,EAAM/C,EACTC,MAAOA,EACPC,OAAQA,EAEX,MAnCCa,EAAO,CACLhB,EAAC,EACDC,EAAC,EACDC,MAAO,EACPC,OAAQ,GAgCZ,OAAOa,CACR,IHpCDpB,EAAS,QD8GK,SAAWjE,GACvB,IAAMa,EAAQb,EAAMW,OACZc,EAAiBZ,EAAK,KACxB8E,EADmB9E,EAAK,OACHA,EAAM8E,UAAY,EAEvC,EA7HR,SAAoBqC,EAAUrC,GAI5B,IAHA,IAAIwB,EAAO,GACPC,EAAO,GACLa,EAAoB,GACjBtG,EAAI,EAAGA,EAAIqG,EAASzG,OAAQI,IAAK,CACxC,IACQkE,GADFH,EAAUsC,EAASrG,IACyB,aAA5BuG,EAAqBxC,EAAO,OAApBE,EAAaF,EAAO,SAC9CyC,OAAG,EACP,OAAQzC,EAAQ0C,SACd,IAAK,IACHD,EAAME,EAAAA,GAAAA,IAAazC,EAAS,GAAIA,EAAS,GAAIsC,EAAO,GAAIA,EAAO,GAAIA,EAAO,GAAIA,EAAO,IACrF,MACF,IAAK,IACHC,EAAMG,EAAAA,GAAAA,IAAc1C,EAAS,GAAIA,EAAS,GAAIsC,EAAO,GAAIA,EAAO,GAAIA,EAAO,GAAIA,EAAO,GAAIA,EAAO,GAAIA,EAAO,IAC5G,MACF,IAAK,IACH,IAAMK,EAAY7C,EAAQ6C,UAC1BJ,EAAMK,EAAAA,GAAAA,IACJD,EAAUE,GACVF,EAAUG,GACVH,EAAUI,GACVJ,EAAUK,GACVL,EAAUM,UACVN,EAAUO,WACVP,EAAUQ,UAEZ,MACF,QACE5B,EAAKjF,KAAK2D,EAAa,IACvBuB,EAAKlF,KAAK2D,EAAa,IAGvBsC,IACFzC,EAAQyC,IAAMA,EACdhB,EAAKjF,KAAKiG,EAAI9D,EAAG8D,EAAI9D,EAAI8D,EAAI5D,OAC7B6C,EAAKlF,KAAKiG,EAAI7D,EAAG6D,EAAI7D,EAAI6D,EAAI3D,SAE3BmB,IAAkC,MAApBD,EAAQ0C,SAAuC,MAApB1C,EAAQ0C,UAAoB1C,EAAQE,UAAYF,EAAQI,WACnGmC,EAAkB/F,KAAKwD,EAE1B,CAIDyB,EAAOA,EAAK6B,QAAO,SAACC,GAAS,OAACC,OAAOC,MAAMF,IAASA,IAASG,KAAYH,KAAS,GAAS,IAC3F7B,EAAOA,EAAK4B,QAAO,SAACC,GAAS,OAACC,OAAOC,MAAMF,IAASA,IAASG,KAAYH,KAAS,GAAS,IAC3F,IAAIpE,GAAOE,EAAAA,EAAAA,IAAIoC,GACXnC,GAAOD,EAAAA,EAAAA,IAAIqC,GACXnC,GAAOC,EAAAA,EAAAA,IAAIiC,GACXhC,GAAOD,EAAAA,EAAAA,IAAIkC,GACf,GAAiC,IAA7Ba,EAAkB1G,OACpB,MAAO,CACL8C,EAAGQ,EACHP,EAAGU,EACHT,MAAOU,EAAOJ,EACdL,OAAQW,EAAOH,GAGnB,IAASrD,EAAI,EAAGA,EAAIsG,EAAkB1G,OAAQI,IAAK,CACjD,IAAM+D,GACEG,GADFH,EAAUuC,EAAkBtG,IACF,cAEf,KAAOkD,EAEtBA,GADQY,EAA6BC,EAASC,GAC1Ba,OACXX,EAAa,KAAOZ,IAE7BA,GADQQ,EAA6BC,EAASC,GAC1Ba,QAElBX,EAAa,KAAOb,EAEtBA,GADQS,EAA6BC,EAASC,GAC1Bc,OACXZ,EAAa,KAAOV,IAE7BA,GADQM,EAA6BC,EAASC,GAC1Bc,OAEvB,CACD,MAAO,CACLpC,EAAGQ,EACHP,EAAGU,EACHT,MAAOU,EAAOJ,EACdL,OAAQW,EAAOH,EAElB,CA0CiCqE,CADfrJ,EAAMqD,IAAI,cAAeiG,EAAAA,EAAAA,IAAc7H,GACHkE,GAA7CtB,EAAC,IAAEC,EAAC,IACRe,EAAO,CACTR,KAAMR,EACNW,KAAMV,EACNW,KAAMZ,EAJW,QAKjBc,KAAMb,EALmB,UAQ3B,MAAO,CACLD,GAFFgB,EAAOD,EAAepF,EAAOqF,IAEnBR,KACRP,EAAGe,EAAKL,KACRT,MAAOc,EAAKJ,KAAOI,EAAKR,KACxBL,OAAQa,EAAKF,KAAOE,EAAKL,KAE5B,IChIDf,EAAS,QIdK,SAAWjE,GACvB,IAAMa,EAAQb,EAAMW,OACZ4I,EAAmB1I,EAAK,GAApB2I,EAAe3I,EAAK,GAAhB4I,EAAW5I,EAAK,GAAZ6I,EAAO7I,EAAK,GAK5BwE,EAAO,CACTR,KALWC,KAAKC,IAAIwE,EAAIE,GAMxBxE,KALWH,KAAKI,IAAIqE,EAAIE,GAMxBzE,KALWF,KAAKC,IAAIyE,EAAIE,GAMxBvE,KALWL,KAAKI,IAAIsE,EAAIE,IAQ1B,MAAO,CACLrF,GAFFgB,EAAOD,EAAepF,EAAOqF,IAEnBR,KACRP,EAAGe,EAAKL,KACRT,MAAOc,EAAKJ,KAAOI,EAAKR,KACxBL,OAAQa,EAAKF,KAAOE,EAAKL,KAE5B,IJLDf,EAAS,WKhBK,SAAWjE,GACvB,IAAMa,EAAQb,EAAMW,OACZ0D,EAAiBxD,EAAK,EAAnByD,EAAczD,EAAK,EAAhB8H,EAAW9H,EAAK,GAAZ+H,EAAO/H,EAAK,GAC9B,MAAO,CACLwD,EAAGA,EAAIsE,EACPrE,EAAGA,EAAIsE,EACPrE,MAAY,EAALoE,EACPnE,OAAa,EAALoE,EAEX,G,+DCDKe,EAAS,CACb,YACA,UACA,WACA,WACA,YACA,YACA,aACA,aACA,aACA,YACA,WACA,YACA,WACA,YACA,OACA,cACA,cAcF,SAASC,EAAgBC,EAAQpK,EAAMqK,GACrCA,EAASC,KAAOtK,EAChBqK,EAASD,OAASA,EAClBC,EAASE,cAAgBH,EACzBC,EAASG,eAAiBJ,EAC1BA,EAAOK,KAAKzK,EAAMqK,EACnB,CAGD,SAASK,EAAYC,EAAW3K,EAAMqK,GACpC,GAAIA,EAASO,QAAS,CACpB,IAAIC,OAAa,EACbC,GAAc,EASlB,GARa,eAAT9K,GACF6K,EAAgBR,EAASU,UACzBD,GAAc,GACI,eAAT9K,IACT8K,GAAc,EACdD,EAAgBR,EAASW,SAGvBL,EAAUM,YAAcH,EAC1B,OAGF,GAAID,IAAiBK,EAAAA,EAAAA,IAASP,EAAWE,GAGvC,YADAR,EAASO,SAAU,GAIrBP,EAASC,KAAOtK,EAChBqK,EAASE,cAAgBI,EACzBN,EAASG,eAAiBG,EAC1BA,EAAUF,KAAKzK,EAAMqK,EACtB,CACF,CAED,iBAYE,WAAYc,GAAZ,WARQ,KAAAC,cAAwB,KACxB,KAAAC,UAAoB,EAEpB,KAAAC,aAAuB,KACvB,KAAAC,eAAyB,KACzB,KAAAC,eAAiB,KAsDzB,KAAAC,eAAiB,SAACC,GAChB,IAAM1L,EAAO0L,EAAG1L,KAChByD,EAAKkI,cAAc3L,EAAM0L,EAC1B,EAiED,KAAAE,gBAAkB,SAACF,GAGjB,GAFejI,EAAKR,OACFW,IAAI,QACX8H,EAAGtB,SAER3G,EAAK4H,UAAY5H,EAAK6H,cAAc,CACtC,IAAMO,EAAYpI,EAAKqI,cAAcJ,GAEjCjI,EAAK4H,UACP5H,EAAKsI,WAAW,OAAQL,EAAIG,EAAWpI,EAAK2H,cAQ/C,CAEJ,EAED,KAAAY,mBAAqB,SAACN,GAGpB,GAFejI,EAAKR,OACFW,IAAI,QACX8H,EAAGtB,QAER3G,EAAK4H,SAAU,CACjB,IAAMQ,EAAYpI,EAAKqI,cAAcJ,GACjCjI,EAAK2H,eAEP3H,EAAKsI,WAAW,OAAQL,EAAIG,EAAW,MAEzCpI,EAAKsI,WAAW,UAAWL,EAAIG,EAAWpI,EAAK2H,eAC/C3H,EAAKwI,WAAWxI,EAAK2H,cAAeS,EAAWH,EAChD,CAEJ,EA1JCrI,KAAKJ,OAASkI,EAAIlI,MACnB,CAiWH,OA/VEiJ,EAAAA,UAAAA,KAAAA,WACE7I,KAAK8I,aACN,EAGDD,EAAAA,UAAAA,YAAAA,WAAA,WACQE,EAAK/I,KAAKJ,OAAOW,IAAI,OAC3ByI,EAAAA,EAAAA,IAAKnC,GAAQ,SAACoC,GACZF,EAAGG,iBAAiBD,EAAW7I,EAAKgI,eACrC,IAEGe,WAGFA,SAASD,iBAAiB,YAAalJ,KAAKuI,iBAE5CY,SAASD,iBAAiB,UAAWlJ,KAAK2I,oBAE7C,EAGDE,EAAAA,UAAAA,aAAAA,WAAA,WACQE,EAAK/I,KAAKJ,OAAOW,IAAI,OAC3ByI,EAAAA,EAAAA,IAAKnC,GAAQ,SAACoC,GACZF,EAAGK,oBAAoBH,EAAW7I,EAAKgI,eACxC,IACGe,WACFA,SAASC,oBAAoB,YAAapJ,KAAKuI,iBAC/CY,SAASC,oBAAoB,UAAWpJ,KAAK2I,oBAEhD,EAEDE,EAAAA,UAAAA,aAAAA,SAAalM,EAAM0M,EAAO9E,EAAOwC,EAAQW,EAAWC,GAClD,IAAMX,EAAW,IAAIsC,EAAAA,EAAW3M,EAAM0M,GAUtC,OATArC,EAASU,UAAYA,EACrBV,EAASW,QAAUA,EACnBX,EAASzF,EAAIgD,EAAMhD,EACnByF,EAASxF,EAAI+C,EAAM/C,EACnBwF,EAASuC,QAAUhF,EAAMgF,QACzBvC,EAASwC,QAAUjF,EAAMiF,QAEzBxC,EAASyC,gBAAgBrK,KAAK2H,GAEvBC,CACR,EASD6B,EAAAA,UAAAA,UAAAA,SAAUtE,EAAO8D,GACf,OAAOrI,KAAKJ,OAAO8J,SAASnF,EAAMhD,EAAGgD,EAAM/C,EAAG6G,EAC/C,EAEDQ,EAAAA,UAAAA,cAAAA,SAAcR,GACZ,IAAMzI,EAASI,KAAKJ,OACd+J,EAAc/J,EAAOgK,iBAAiBvB,GACtC9D,EAAQ3E,EAAOiK,gBAAgBxB,GACrC,MAAO,CACL9G,EAAGgD,EAAMhD,EACTC,EAAG+C,EAAM/C,EACT+H,QAASI,EAAYpI,EACrBiI,QAASG,EAAYnI,EAExB,EAGDqH,EAAAA,UAAAA,cAAAA,SAAclM,EAAM0L,GAClB,IAAMG,EAAYxI,KAAKyI,cAAcJ,GAE/BnL,EAAQ8C,KAAK8J,UAAUtB,EAAWH,GAClCjH,EAASpB,KAAK,MAAMrD,GACtBoN,GAAc,EAClB,GAAI3I,EACFA,EAAO4I,KAAKhK,KAAMwI,EAAWtL,EAAOmL,OAC/B,CACL,IAAM4B,EAAWjK,KAAKiI,aAET,eAATtL,GAAkC,cAATA,GAAiC,cAATA,GACnDqD,KAAK0I,WAAW/L,EAAM0L,EAAIG,EAAW,KAAM,KAAMtL,GAC7CA,GACF8C,KAAK0I,WAAW/L,EAAM0L,EAAIG,EAAWtL,EAAO,KAAMA,GAEvC,eAATP,GAAyBqD,KAAK+H,eAEhC/H,KAAK0I,WAAW,YAAaL,EAAIG,EAAW,OAE5B,eAAT7L,GAAkC,cAATA,GAAiC,aAATA,GAC1DoN,GAAc,EACVE,GACFjK,KAAK0I,WAAW/L,EAAM0L,EAAIG,EAAWyB,EAAUA,EAAU,MAE3DjK,KAAK0I,WAAW/L,EAAM0L,EAAIG,EAAW,KAAMyB,EAAU,MACxC,eAATtN,GAAyBqD,KAAK+H,eAChC/H,KAAK0I,WAAW,YAAaL,EAAIG,EAAW,OAG9CxI,KAAK0I,WAAW/L,EAAM0L,EAAIG,EAAWtL,EAAO,KAAM,KAErD,CAKD,GAJK6M,IACH/J,KAAKiI,aAAe/K,GAGlBA,IAAUA,EAAMqD,IAAI,aAAc,CACpC,IAAMX,EAASI,KAAKJ,OACTA,EAAOW,IAAI,MACnB2J,MAAMC,OAASjN,EAAMW,KAAK,WAAa+B,EAAOW,IAAI,SACtD,CACF,EA0CDsI,EAAAA,UAAAA,aAAAA,SAAaL,EAAWtL,EAAOmM,GAlPX,IAoPdA,EAAMe,SACRpK,KAAKkI,eAAiBhL,EACtB8C,KAAKmI,eAAiBK,EACtBxI,KAAKqK,mBAAqBhB,EAAMiB,WAElCtK,KAAK0I,WAAW,YAAaW,EAAOb,EAAWtL,EAAO,KAAM,KAC7D,EAID2L,EAAAA,UAAAA,qBAAAA,SAAqBQ,EAAOb,EAAWd,EAAWC,GAChD,IAAMoB,EAAK/I,KAAKJ,OAAOW,IAAI,MACvBmH,IAAcC,IACZD,IACF1H,KAAK0I,WAAW,WAAYW,EAAOb,EAAWd,EAAWA,EAAWC,GACpE3H,KAAK0I,WAAW,aAAcW,EAAOb,EAAWd,EAAWA,EAAWC,GAEjEA,IAAWA,EAAQpH,IAAI,eAC1BwI,EAAGmB,MAAMC,OAASnK,KAAKJ,OAAOW,IAAI,YAGlCoH,IACF3H,KAAK0I,WAAW,YAAaW,EAAOb,EAAWb,EAASD,EAAWC,GACnE3H,KAAK0I,WAAW,aAAcW,EAAOb,EAAWb,EAASD,EAAWC,IAGzE,EAEDkB,EAAAA,UAAAA,oBAAAA,SAAoBQ,EAAOb,EAAWd,EAAWC,EAAS4C,GACpD5C,GACEA,IAAYD,IACVA,GACF1H,KAAK0I,WAAW,YAAaW,EAAOb,EAAWd,EAAWA,EAAWC,GAEvE3H,KAAK0I,WAAW,YAAaW,EAAOb,EAAWb,EAASD,EAAWC,IAEhE4C,GACHvK,KAAK0I,WAAW,WAAYW,EAAOb,EAAWb,IAEvCD,GAGT1H,KAAK0I,WAAW,YAAaW,EAAOb,EAAWd,EAAWA,EAAWC,GAGnE4C,GACFvK,KAAK0I,WAAW,WAAYW,EAAOb,EAAWb,EAEjD,EAGDkB,EAAAA,UAAAA,WAAAA,SAAWd,EAAeS,EAAWa,GAC/BtB,IACFA,EAAc1G,IAAI,WAAW,GAC7BrB,KAAK+H,cAAgB,MAEvB/H,KAAKgI,UAAW,EAEhB,IAAM9K,EAAQ8C,KAAK8J,UAAUtB,EAAWa,GAEpCnM,IAAU6K,GACZ/H,KAAKwK,qBAAqBnB,EAAOb,EAAWT,EAAe7K,GAE7D8C,KAAKiI,aAAe/K,CACrB,EAED2L,EAAAA,UAAAA,WAAAA,SAAWL,EAAWtL,EAAOmM,GAG3B,GAzTkB,IAyTdA,EAAMe,OAA0B,CAClC,IAAMrC,EAAgB/H,KAAK+H,cACvB/H,KAAKgI,UAEHD,GACF/H,KAAK0I,WAAW,OAAQW,EAAOb,EAAWtL,GAE5C8C,KAAK0I,WAAW,UAAWW,EAAOb,EAAWT,GAC7C/H,KAAK4I,WAAWb,EAAeS,EAAWa,KAE1CrJ,KAAK0I,WAAW,UAAWW,EAAOb,EAAWtL,GACzCA,IAAU8C,KAAKkI,gBACjBlI,KAAK0I,WAAW,QAASW,EAAOb,EAAWtL,GAE7C8C,KAAKkI,eAAiB,KACtBlI,KAAKmI,eAAiB,KAEzB,CACF,EAGDU,EAAAA,UAAAA,YAAAA,SAAYL,EAAWtL,EAAOmM,GAC5BA,EAAMoB,iBACN,IAAMR,EAAWjK,KAAKiI,aACtBjI,KAAK0K,oBAAoBrB,EAAOb,EAAWyB,EAAU/M,GAAO,EAC7D,EAGD2L,EAAAA,UAAAA,aAAAA,SAAaL,EAAWtL,EAAOmM,GAC7B,IAAMzJ,EAASI,KAAKJ,OACdqK,EAAWjK,KAAKiI,aAClBF,EAAgB/H,KAAK+H,cAEzB,GAAI/H,KAAKgI,SAEHD,GAEF/H,KAAK0K,oBAAoBrB,EAAOb,EAAWyB,EAAU/M,GAAO,GAI9D8C,KAAK0I,WAAW,OAAQW,EAAOb,EAAWT,OACrC,CACL,IAAMI,EAAiBnI,KAAKmI,eAC5B,GAAIA,EAAgB,CAElB,IAAMD,EAAiBlI,KAAKkI,eAEtByC,EADMtB,EAAMiB,UACOtK,KAAKqK,mBACxBO,EAAKzC,EAAeoB,QAAUf,EAAUe,QACxCsB,EAAK1C,EAAeqB,QAAUhB,EAAUgB,QAE1CmB,EAAa,KADJC,EAAKA,EAAKC,EAAKA,EA7Wf,GA+WP3C,GAAkBA,EAAe3H,IAAI,eAEvCwH,EAAgB/H,KAAKkI,gBACP7G,IAAI,WAAW,GAC7BrB,KAAK+H,cAAgBA,EACrB/H,KAAKgI,UAAW,EAChBhI,KAAK0I,WAAW,YAAaW,EAAOb,EAAWT,GAE/C/H,KAAKkI,eAAiB,KACtBlI,KAAKmI,eAAiB,OACZD,GAAkBtI,EAAOW,IAAI,cAEvCP,KAAKgI,UAAW,EAChBhI,KAAK0I,WAAW,YAAaW,EAAOb,EAAW,MAE/CxI,KAAKkI,eAAiB,KACtBlI,KAAKmI,eAAiB,OAEtBnI,KAAKwK,qBAAqBnB,EAAOb,EAAWyB,EAAU/M,GACtD8C,KAAK0I,WAAW,YAAaW,EAAOb,EAAWtL,KAGjD8C,KAAKwK,qBAAqBnB,EAAOb,EAAWyB,EAAU/M,GACtD8C,KAAK0I,WAAW,YAAaW,EAAOb,EAAWtL,GAElD,MAEC8C,KAAKwK,qBAAqBnB,EAAOb,EAAWyB,EAAU/M,GAEtD8C,KAAK0I,WAAW,YAAaW,EAAOb,EAAWtL,EAElD,CACF,EAGD2L,EAAAA,UAAAA,WAAAA,SAAWlM,EAAM0M,EAAOb,EAAWtL,EAAOwK,EAAYC,GACpD,IAAMX,EAAWhH,KAAK8K,aAAanO,EAAM0M,EAAOb,EAAWtL,EAAOwK,EAAWC,GAE7E,GAAIzK,EAAO,CACT8J,EAAS9J,MAAQA,EAEjB4J,EAAgB5J,EAAOP,EAAMqK,GAG7B,IAFA,IAAI+D,EAAS7N,EAAM8N,YAEZD,GAELA,EAAOE,eAAetO,EAAMqK,GAEvBA,EAASkE,oBACZ7D,EAAY0D,EAAQpO,EAAMqK,GAE5BA,EAASyC,gBAAgBrK,KAAK2L,GAC9BA,EAASA,EAAOC,WAEnB,KAAM,CAILlE,EAFe9G,KAAKJ,OAEIjD,EAAMqK,EAC/B,CACF,EAED6B,EAAAA,UAAAA,QAAAA,WAEE7I,KAAKmL,eAELnL,KAAKJ,OAAS,KACdI,KAAKiI,aAAe,KACpBjI,KAAK+H,cAAgB,KACrB/H,KAAKmI,eAAiB,KACtBnI,KAAKkI,eAAiB,KACtBlI,KAAKqK,mBAAqB,IAC3B,EACH,CAAC,CA/WD,GAiXA,K,mCC9bA,iBAiGE,WAAY1N,EAAM0M,GA9DlB,KAAA9B,SAAmB,EAKnB,KAAAR,OAAsB,KAKtB,KAAAG,cAA6B,KAK7B,KAAAC,eAA8B,KAK9B,KAAAiE,eAAyB,KAKzB,KAAAC,kBAA4B,EAK5B,KAAAH,oBAA8B,EAK9B,KAAAhO,MAAgB,KAKhB,KAAAwK,UAAoB,KAKpB,KAAAC,QAAkB,KAelB,KAAA8B,gBAAyB,GAGvBzJ,KAAKrD,KAAOA,EACZqD,KAAKiH,KAAOtK,EACZqD,KAAKsL,cAAgBjC,EACrBrJ,KAAKsK,UAAYjB,EAAMiB,SACxB,CA2BH,OAtBEhB,EAAAA,UAAAA,eAAAA,WACEtJ,KAAKqL,kBAAmB,EACpBrL,KAAKsL,cAAcb,gBACrBzK,KAAKsL,cAAcb,gBAEtB,EAKDnB,EAAAA,UAAAA,gBAAAA,WACEtJ,KAAKkL,oBAAqB,CAC3B,EAED5B,EAAAA,UAAAA,SAAAA,WAEE,MAAO,gBADMtJ,KAAKrD,KACS,IAC5B,EAED2M,EAAAA,UAAAA,KAAAA,WAAS,EAETA,EAAAA,UAAAA,QAAAA,WAAY,EACd,CAAC,CAjID,GAmIA,K,m5CC/GaiC,EAAU,Q,yECZjB,SAAUC,EAAeC,EAAaC,GAC1C,IAAMC,EAAM,GACNC,EAAMH,EAAE,GACRI,EAAMJ,EAAE,GACRK,EAAML,EAAE,GAERM,EAAMN,EAAE,GACRO,EAAMP,EAAE,GACRQ,EAAMR,EAAE,GACRS,EAAMT,EAAE,GACRU,EAAMV,EAAE,GACRW,EAAMX,EAAE,GAERY,EAAMX,EAAE,GACRY,EAAMZ,EAAE,GACRa,EAAMb,EAAE,GACRc,EAAMd,EAAE,GACRe,EAAMf,EAAE,GACRgB,EAAMhB,EAAE,GACRiB,EAAMjB,EAAE,GACRkB,EAAMlB,EAAE,GACRmB,EAAMnB,EAAE,GAad,OAXAC,EAAI,GAAKU,EAAMT,EAAMU,EAAMP,EAAMQ,EAAML,EACvCP,EAAI,GAAKU,EAAMR,EAAMS,EAAMN,EAAMO,EAAMJ,EACvCR,EAAI,GAAKU,EAAMP,EAAMQ,EAAML,EAAMM,EAAMH,EAEvCT,EAAI,GAAKa,EAAMZ,EAAMa,EAAMV,EAAMW,EAAMR,EACvCP,EAAI,GAAKa,EAAMX,EAAMY,EAAMT,EAAMU,EAAMP,EACvCR,EAAI,GAAKa,EAAMV,EAAMW,EAAMR,EAAMS,EAAMN,EAEvCT,EAAI,GAAKgB,EAAMf,EAAMgB,EAAMb,EAAMc,EAAMX,EACvCP,EAAI,GAAKgB,EAAMd,EAAMe,EAAMZ,EAAMa,EAAMV,EACvCR,EAAI,GAAKgB,EAAMb,EAAMc,EAAMX,EAAMY,EAAMT,EAChCT,CACR,CAOK,SAAUmB,EAAaC,EAAaC,GACxC,IAAMrB,EAAM,GACNpK,EAAIyL,EAAE,GACNxL,EAAIwL,EAAE,GAGZ,OAFArB,EAAI,GAAKoB,EAAE,GAAKxL,EAAIwL,EAAE,GAAKvL,EAAIuL,EAAE,GACjCpB,EAAI,GAAKoB,EAAE,GAAKxL,EAAIwL,EAAE,GAAKvL,EAAIuL,EAAE,GAC1BpB,CACR,CAMK,SAAUsB,EAAOxB,GACrB,IAAME,EAAM,GACNC,EAAMH,EAAE,GACRI,EAAMJ,EAAE,GACRK,EAAML,EAAE,GACRM,EAAMN,EAAE,GACRO,EAAMP,EAAE,GACRQ,EAAMR,EAAE,GACRS,EAAMT,EAAE,GACRU,EAAMV,EAAE,GACRW,EAAMX,EAAE,GAERa,EAAMF,EAAMJ,EAAMC,EAAME,EACxBM,GAAOL,EAAML,EAAME,EAAMC,EACzBU,EAAMT,EAAMJ,EAAMC,EAAME,EAG1BgB,EAAMtB,EAAMU,EAAMT,EAAMY,EAAMX,EAAMc,EAExC,OAAKM,GAGLA,EAAM,EAAMA,EAEZvB,EAAI,GAAKW,EAAMY,EACfvB,EAAI,KAAOS,EAAMP,EAAMC,EAAMK,GAAOe,EACpCvB,EAAI,IAAMM,EAAMJ,EAAMC,EAAME,GAAOkB,EACnCvB,EAAI,GAAKc,EAAMS,EACfvB,EAAI,IAAMS,EAAMR,EAAME,EAAMI,GAAOgB,EACnCvB,EAAI,KAAOM,EAAML,EAAME,EAAMC,GAAOmB,EACpCvB,EAAI,GAAKiB,EAAMM,EACfvB,EAAI,KAAOQ,EAAMP,EAAMC,EAAMK,GAAOgB,EACpCvB,EAAI,IAAMK,EAAMJ,EAAMC,EAAME,GAAOmB,EAC5BvB,GAbE,IAcV,C,qJCnGD,IAAIwB,EAAe,KACb,SAAUC,IACd,IAAKD,EAAc,CACjB,IAAMvN,EAASuJ,SAASkE,cAAc,UACtCzN,EAAO6B,MAAQ,EACf7B,EAAO8B,OAAS,EAChByL,EAAevN,EAAO0N,WAAW,KAClC,CACD,OAAOH,CACR,C,gJCAK,SAAUlI,EAAcR,EAAcC,EAAkBC,GAC5D,IAAI4I,EAAY,EAIhB,IAHIC,EAAAA,EAAAA,IAAS/I,KACX8I,EAAY9I,EAAKgJ,MAAM,MAAMhP,QAE3B8O,EAAY,EAAG,CACjB,IAAMG,EAWJ,SAA0BhJ,EAAkBC,GAChD,OAAOA,EAAaA,EAAaD,EAAsB,IAAXA,CAC7C,CAbqBiJ,CAAgBjJ,EAAUC,GAC5C,OAAOD,EAAW6I,EAAYG,GAAaH,EAAY,EACxD,CACD,OAAO7I,CACR,CAgBK,SAAUI,EAAaL,EAAcG,GACzC,IAAMgJ,GAAUR,EAAAA,EAAAA,KACZ3L,EAAQ,EAEZ,IAAIoM,EAAAA,EAAAA,IAAMpJ,IAAkB,KAATA,EACjB,OAAOhD,EAIT,GAFAmM,EAAQE,OACRF,EAAQhJ,KAAOA,GACX4I,EAAAA,EAAAA,IAAS/I,IAASA,EAAKjF,SAAS,MAAO,CACzC,IAAMuO,EAAUtJ,EAAKgJ,MAAM,OAC3BzE,EAAAA,EAAAA,IAAK+E,GAAS,SAACC,GACb,IAAMC,EAAeL,EAAQM,YAAYF,GAASvM,MAC9CA,EAAQwM,IACVxM,EAAQwM,EAEX,GACF,MACCxM,EAAQmM,EAAQM,YAAYzJ,GAAMhD,MAGpC,OADAmM,EAAQO,UACD1M,CACR,CAEK,SAAUoD,EAAa9G,GACnB,IAAA2G,EAA6D3G,EAAK,SAAxDqQ,EAAmDrQ,EAAK,WAA5CsQ,EAAuCtQ,EAAK,WAC1E,MAAO,CAD8DA,EAAK,UAALA,EAAK,YAC1CsQ,EAAe3J,EAAQ,KAAM0J,GAAYE,KAAK,KAAKC,MACpF,C,0VC9DK,SAAUC,EAAgBC,EAAYC,GAC1C,IAAM/N,EAAQ8N,EAAIE,QAAQD,IACX,IAAX/N,GACF8N,EAAIjO,OAAOG,EAAO,EAErB,CAEM,IAAMiO,EAA8B,qBAAXC,QAAqD,qBAApBA,OAAO1F,SAIlE,SAAUtB,EAASP,EAAWpK,GAElC,GAAIoK,EAAUM,WACZ,OAAO,EAIT,IAFA,IAAIkH,EAAS5R,EAAM8N,YACfnD,GAAW,EACRiH,GAAQ,CACb,GAAIA,IAAWxH,EAAW,CACxBO,GAAW,EACX,KACD,CACDiH,EAASA,EAAO9D,WACjB,CACD,OAAOnD,CACR,CAEK,SAAUkH,EAAeC,GAE7B,OAAOA,EAAQlH,IAAImH,SAAWD,EAAQlH,IAAIoH,OAC3C,C","sources":["../node_modules/@antv/g-base/src/animate/register.ts","../node_modules/@antv/g-base/src/animate/timeline.ts","../node_modules/@antv/g-base/src/util/color.ts","../node_modules/@antv/g-base/src/bbox/register.ts","../node_modules/@antv/g-base/src/bbox/rect.ts","../node_modules/@antv/g-base/src/bbox/circle.ts","../node_modules/@antv/g-base/src/bbox/util.ts","../node_modules/@antv/g-base/src/bbox/path.ts","../node_modules/@antv/g-base/src/bbox/index.ts","../node_modules/@antv/g-base/src/bbox/polyline.ts","../node_modules/@antv/g-base/src/bbox/polygon.ts","../node_modules/@antv/g-base/src/bbox/text.ts","../node_modules/@antv/g-base/src/bbox/line.ts","../node_modules/@antv/g-base/src/bbox/ellipse.ts","../node_modules/@antv/g-base/src/event/event-contoller.ts","../node_modules/@antv/g-base/src/event/graph-event.ts","../node_modules/@antv/g-base/src/index.ts","../node_modules/@antv/g-base/src/util/matrix.ts","../node_modules/@antv/g-base/src/util/offscreen.ts","../node_modules/@antv/g-base/src/util/text.ts","../node_modules/@antv/g-base/src/util/util.ts"],"sourcesContent":["import * as d3Ease from 'd3-ease';\n\ntype EaseFn = (t: number) => number;\n\ninterface EasingMap {\n  [key: string]: EaseFn;\n}\n\nconst EASING_MAP: EasingMap = {};\n\n/**\n * 根据名称获取对应的动画缓动函数\n * @param type 动画缓动函数名称\n */\nexport function getEasing(type: string) {\n  // 默认从 d3-ease 中获取\n  return EASING_MAP[type.toLowerCase()] || d3Ease[type];\n}\n\n/**\n * 注册动画缓动函数\n * @param type 动画缓动函数名称\n * @param easeFn 动画缓动函数\n */\nexport function registerEasing(type: string, easeFn: EaseFn) {\n  EASING_MAP[type.toLowerCase()] = easeFn;\n}\n","import { isEqual, isNumber, isFunction } from '@antv/util';\nimport * as d3Timer from 'd3-timer';\nimport { interpolate, interpolateArray } from 'd3-interpolate'; // 目前整体动画只需要数值和数组的差值计算\nimport { getEasing } from './register';\nimport * as PathUtil from '../util/path';\nimport { isColorProp, isGradientColor } from '../util/color';\nimport { ICanvas, IElement } from '../interfaces';\nimport { Animation } from '../types';\n\nconst IDENTITY_MATRIX = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n\n/**\n * 使用 ratio 进行插值计算来更新属性\n * @param {IElement}  shape    元素\n * @param {Animation} animation 动画\n * @param {number}    ratio    比例\n * @return {boolean}  动画是否执行完成\n */\nfunction _update(shape: IElement, animation: Animation, ratio: number) {\n  const cProps = {}; // 此刻属性\n  const { fromAttrs, toAttrs } = animation;\n  if (shape.destroyed) {\n    return;\n  }\n  let interf; //  差值函数\n  for (const k in toAttrs) {\n    if (!isEqual(fromAttrs[k], toAttrs[k])) {\n      if (k === 'path') {\n        let toPath = toAttrs[k];\n        let fromPath = fromAttrs[k];\n        if (toPath.length > fromPath.length) {\n          toPath = PathUtil.parsePathString(toAttrs[k]); // 终点状态\n          fromPath = PathUtil.parsePathString(fromAttrs[k]); // 起始状态\n          fromPath = PathUtil.fillPathByDiff(fromPath, toPath);\n          fromPath = PathUtil.formatPath(fromPath, toPath);\n          animation.fromAttrs.path = fromPath;\n          animation.toAttrs.path = toPath;\n        } else if (!animation.pathFormatted) {\n          toPath = PathUtil.parsePathString(toAttrs[k]);\n          fromPath = PathUtil.parsePathString(fromAttrs[k]);\n          fromPath = PathUtil.formatPath(fromPath, toPath);\n          animation.fromAttrs.path = fromPath;\n          animation.toAttrs.path = toPath;\n          animation.pathFormatted = true;\n        }\n        cProps[k] = [];\n        for (let i = 0; i < toPath.length; i++) {\n          const toPathPoint = toPath[i];\n          const fromPathPoint = fromPath[i];\n          const cPathPoint = [];\n          for (let j = 0; j < toPathPoint.length; j++) {\n            if (isNumber(toPathPoint[j]) && fromPathPoint && isNumber(fromPathPoint[j])) {\n              interf = interpolate(fromPathPoint[j], toPathPoint[j]);\n              cPathPoint.push(interf(ratio));\n            } else {\n              cPathPoint.push(toPathPoint[j]);\n            }\n          }\n          cProps[k].push(cPathPoint);\n        }\n      } else if (k === 'matrix') {\n        /* \n         对矩阵进行插值时，需要保证矩阵不为空，为空则使用单位矩阵\n         TODO: 二维和三维场景下单位矩阵不同，之后 WebGL 版需要做进一步处理\n         */\n        const matrixFn = interpolateArray(fromAttrs[k] || IDENTITY_MATRIX, toAttrs[k] || IDENTITY_MATRIX);\n        const currentMatrix = matrixFn(ratio);\n        cProps[k] = currentMatrix;\n      } else if (isColorProp(k) && isGradientColor(toAttrs[k])) {\n        cProps[k] = toAttrs[k];\n      } else if (!isFunction(toAttrs[k])) {\n        // 非函数类型的值才能做插值\n        interf = interpolate(fromAttrs[k], toAttrs[k]);\n        cProps[k] = interf(ratio);\n      }\n    }\n  }\n  shape.attr(cProps);\n}\n\n/**\n * 根据自定义帧动画函数 onFrame 来更新属性\n * @param {IElement}  shape    元素\n * @param {Animation} animation 动画\n * @param {number}    elapsed  动画执行时间(毫秒)\n * @return {boolean}  动画是否执行完成\n */\nfunction update(shape: IElement, animation: Animation, elapsed: number) {\n  const { startTime, delay } = animation;\n  // 如果还没有开始执行或暂停，先不更新\n  if (elapsed < startTime + delay || animation._paused) {\n    return false;\n  }\n  let ratio;\n  const duration = animation.duration;\n  const easing = animation.easing;\n  const easeFn = getEasing(easing);\n\n  // 已执行时间\n  elapsed = elapsed - startTime - animation.delay;\n  if (animation.repeat) {\n    // 如果动画重复执行，则 elapsed > duration，计算 ratio 时需取模\n    ratio = (elapsed % duration) / duration;\n    ratio = easeFn(ratio);\n  } else {\n    ratio = elapsed / duration;\n    if (ratio < 1) {\n      // 动画未执行完\n      ratio = easeFn(ratio);\n    } else {\n      // 动画已执行完\n      if (animation.onFrame) {\n        shape.attr(animation.onFrame(1));\n      } else {\n        shape.attr(animation.toAttrs);\n      }\n      return true;\n    }\n  }\n  if (animation.onFrame) {\n    const attrs = animation.onFrame(ratio);\n    shape.attr(attrs);\n  } else {\n    _update(shape, animation, ratio);\n  }\n  return false;\n}\n\nclass Timeline {\n  /**\n   * 画布\n   * @type {ICanvas}\n   */\n  canvas: ICanvas;\n  /**\n   * 执行动画的元素列表\n   * @type {IElement[]}\n   */\n  animators: IElement[] = [];\n  /**\n   * 当前时间\n   * @type {number}\n   */\n  current: number = 0;\n  /**\n   * 定时器\n   * @type {d3Timer.Timer}\n   */\n  timer: d3Timer.Timer = null;\n\n  /**\n   * 时间轴构造函数，依赖于画布\n   * @param {}\n   */\n  constructor(canvas: ICanvas) {\n    this.canvas = canvas;\n  }\n\n  /**\n   * 初始化定时器\n   */\n  initTimer() {\n    let isFinished = false;\n    let shape: IElement;\n    let animations: Animation[];\n    let animation: Animation;\n    this.timer = d3Timer.timer((elapsed) => {\n      this.current = elapsed;\n      if (this.animators.length > 0) {\n        for (let i = this.animators.length - 1; i >= 0; i--) {\n          shape = this.animators[i];\n          if (shape.destroyed) {\n            // 如果已经被销毁，直接移出队列\n            this.removeAnimator(i);\n            continue;\n          }\n          if (!shape.isAnimatePaused()) {\n            animations = shape.get('animations');\n            for (let j = animations.length - 1; j >= 0; j--) {\n              animation = animations[j];\n              isFinished = update(shape, animation, elapsed);\n              if (isFinished) {\n                animations.splice(j, 1);\n                isFinished = false;\n                if (animation.callback) {\n                  animation.callback();\n                }\n              }\n            }\n          }\n          if (animations.length === 0) {\n            this.removeAnimator(i);\n          }\n        }\n        const autoDraw = this.canvas.get('autoDraw');\n        // 非自动渲染模式下，手动调用 canvas.draw() 重新渲染\n        if (!autoDraw) {\n          this.canvas.draw();\n        }\n      }\n    });\n  }\n\n  /**\n   * 增加动画元素\n   */\n  addAnimator(shape) {\n    this.animators.push(shape);\n  }\n\n  /**\n   * 移除动画元素\n   */\n  removeAnimator(index) {\n    this.animators.splice(index, 1);\n  }\n\n  /**\n   * 是否有动画在执行\n   */\n  isAnimating() {\n    return !!this.animators.length;\n  }\n\n  /**\n   * 停止定时器\n   */\n  stop() {\n    if (this.timer) {\n      this.timer.stop();\n    }\n  }\n\n  /**\n   * 停止时间轴上所有元素的动画，并置空动画元素列表\n   * @param {boolean} toEnd 是否到动画的最终状态，用来透传给动画元素的 stopAnimate 方法\n   */\n  stopAllAnimations(toEnd = true) {\n    this.animators.forEach((animator) => {\n      animator.stopAnimate(toEnd);\n    });\n    this.animators = [];\n    this.canvas.draw();\n  }\n\n  /**\n   * 获取当前时间\n   */\n  getTime() {\n    return this.current;\n  }\n}\n\nexport default Timeline;\n","export const isColorProp = (prop) => ['fill', 'stroke', 'fillStyle', 'strokeStyle'].includes(prop);\n\nexport const isGradientColor = (val) => /^[r,R,L,l]{1}[\\s]*\\(/.test(val);\n","import { SimpleBBox } from '../types';\nimport { IShape } from '../interfaces';\ntype BoxMethod = (shape: IShape) => SimpleBBox;\nconst cache: Map<string, BoxMethod> = new Map<string, BoxMethod>();\n\n/**\n * 注册计算包围盒的算法\n * @param type 方法名\n * @param method 方法\n */\nexport function register(type: string, method: BoxMethod) {\n  cache.set(type, method);\n}\n\n/**\n * 获取计算包围盒的算法\n * @param type 方法名\n */\nexport function getMethod(type: string): BoxMethod {\n  return cache.get(type);\n}\n","import { SimpleBBox } from '../types';\nimport { IShape } from '../interfaces';\n\nexport default function (shape: IShape): SimpleBBox {\n  const attrs = shape.attr();\n  const { x, y, width, height } = attrs;\n  return {\n    x,\n    y,\n    width,\n    height,\n  };\n}\n","import { SimpleBBox } from '../types';\nimport { IShape } from '../interfaces';\n\nexport default function (shape: IShape): SimpleBBox {\n  const { x, y, r } = shape.attr();\n  return {\n    x: x - r,\n    y: y - r,\n    width: r * 2,\n    height: r * 2,\n  };\n}\n","import { IShape } from '../interfaces';\n\n// 合并包围盒\nexport function mergeBBox(bbox1, bbox2) {\n  if (!bbox1 || !bbox2) {\n    return bbox1 || bbox2;\n  }\n  return {\n    minX: Math.min(bbox1.minX, bbox2.minX),\n    minY: Math.min(bbox1.minY, bbox2.minY),\n    maxX: Math.max(bbox1.maxX, bbox2.maxX),\n    maxY: Math.max(bbox1.maxY, bbox2.maxY),\n  };\n}\n\n// 合并箭头的包围盒\nexport function mergeArrowBBox(shape: IShape, bbox) {\n  const startArrowShape = shape.get('startArrowShape');\n  const endArrowShape = shape.get('endArrowShape');\n  let startArrowBBox = null;\n  let endArrowBBox = null;\n  if (startArrowShape) {\n    startArrowBBox = startArrowShape.getCanvasBBox();\n    bbox = mergeBBox(bbox, startArrowBBox);\n  }\n  if (endArrowShape) {\n    endArrowBBox = endArrowShape.getCanvasBBox();\n    bbox = mergeBBox(bbox, endArrowBBox);\n  }\n  return bbox;\n}\n","import { Quad as QuadUtil, Cubic as CubicUtil, Arc as EllipseArcUtil } from '@antv/g-math';\nimport { path2Segments } from '@antv/path-util';\nimport { isNumberEqual, max, min } from '@antv/util';\nimport { SimpleBBox } from '../types';\nimport { IShape } from '../interfaces';\nimport { mergeArrowBBox } from './util';\n\nfunction getPathBox(segments, lineWidth) {\n  let xArr = [];\n  let yArr = [];\n  const segmentsWithAngle = [];\n  for (let i = 0; i < segments.length; i++) {\n    const segment = segments[i];\n    const { currentPoint, params, prePoint } = segment;\n    let box;\n    switch (segment.command) {\n      case 'Q':\n        box = QuadUtil.box(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4]);\n        break;\n      case 'C':\n        box = CubicUtil.box(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4], params[5], params[6]);\n        break;\n      case 'A':\n        const arcParams = segment.arcParams;\n        box = EllipseArcUtil.box(\n          arcParams.cx,\n          arcParams.cy,\n          arcParams.rx,\n          arcParams.ry,\n          arcParams.xRotation,\n          arcParams.startAngle,\n          arcParams.endAngle\n        );\n        break;\n      default:\n        xArr.push(currentPoint[0]);\n        yArr.push(currentPoint[1]);\n        break;\n    }\n    if (box) {\n      segment.box = box;\n      xArr.push(box.x, box.x + box.width);\n      yArr.push(box.y, box.y + box.height);\n    }\n    if (lineWidth && (segment.command === 'L' || segment.command === 'M') && segment.prePoint && segment.nextPoint) {\n      segmentsWithAngle.push(segment);\n    }\n  }\n  // bbox calculation should ignore NaN for path attribute\n  // ref: https://github.com/antvis/g/issues/210\n  // ref: https://github.com/antvis/G2/issues/3109\n  xArr = xArr.filter((item) => !Number.isNaN(item) && item !== Infinity && item !== -Infinity);\n  yArr = yArr.filter((item) => !Number.isNaN(item) && item !== Infinity && item !== -Infinity);\n  let minX = min(xArr);\n  let minY = min(yArr);\n  let maxX = max(xArr);\n  let maxY = max(yArr);\n  if (segmentsWithAngle.length === 0) {\n    return {\n      x: minX,\n      y: minY,\n      width: maxX - minX,\n      height: maxY - minY,\n    };\n  }\n  for (let i = 0; i < segmentsWithAngle.length; i++) {\n    const segment = segmentsWithAngle[i];\n    const { currentPoint } = segment;\n    let extra;\n    if (currentPoint[0] === minX) {\n      extra = getExtraFromSegmentWithAngle(segment, lineWidth);\n      minX = minX - extra.xExtra;\n    } else if (currentPoint[0] === maxX) {\n      extra = getExtraFromSegmentWithAngle(segment, lineWidth);\n      maxX = maxX + extra.xExtra;\n    }\n    if (currentPoint[1] === minY) {\n      extra = getExtraFromSegmentWithAngle(segment, lineWidth);\n      minY = minY - extra.yExtra;\n    } else if (currentPoint[1] === maxY) {\n      extra = getExtraFromSegmentWithAngle(segment, lineWidth);\n      maxY = maxY + extra.yExtra;\n    }\n  }\n  return {\n    x: minX,\n    y: minY,\n    width: maxX - minX,\n    height: maxY - minY,\n  };\n}\n\nfunction getExtraFromSegmentWithAngle(segment, lineWidth) {\n  const { prePoint, currentPoint, nextPoint } = segment;\n  const currentAndPre = Math.pow(currentPoint[0] - prePoint[0], 2) + Math.pow(currentPoint[1] - prePoint[1], 2);\n  const currentAndNext = Math.pow(currentPoint[0] - nextPoint[0], 2) + Math.pow(currentPoint[1] - nextPoint[1], 2);\n  const preAndNext = Math.pow(prePoint[0] - nextPoint[0], 2) + Math.pow(prePoint[1] - nextPoint[1], 2);\n  // 以 currentPoint 为顶点的夹角\n  const currentAngle = Math.acos(\n    (currentAndPre + currentAndNext - preAndNext) / (2 * Math.sqrt(currentAndPre) * Math.sqrt(currentAndNext))\n  );\n  // 夹角为空、 0 或 PI 时，不需要计算夹角处的额外宽度\n  // 注意: 由于计算精度问题，夹角为 0 的情况计算出来的角度可能是一个很小的值，还需要判断其与 0 是否近似相等\n  if (!currentAngle || Math.sin(currentAngle) === 0 || isNumberEqual(currentAngle, 0)) {\n    return {\n      xExtra: 0,\n      yExtra: 0,\n    };\n  }\n  let xAngle = Math.abs(Math.atan2(nextPoint[1] - currentPoint[1], nextPoint[0] - currentPoint[0]));\n  let yAngle = Math.abs(Math.atan2(nextPoint[0] - currentPoint[0], nextPoint[1] - currentPoint[1]));\n  // 将夹角转为锐角\n  xAngle = xAngle > Math.PI / 2 ? Math.PI - xAngle : xAngle;\n  yAngle = yAngle > Math.PI / 2 ? Math.PI - yAngle : yAngle;\n  // 这里不考虑在水平和垂直方向的投影，直接使用最大差值\n  // 由于上层统一加减了二分之一线宽，这里需要进行弥补\n  const extra = {\n    // 水平方向投影\n    xExtra:\n      Math.cos(currentAngle / 2 - xAngle) * ((lineWidth / 2) * (1 / Math.sin(currentAngle / 2))) - lineWidth / 2 || 0,\n    // 垂直方向投影\n    yExtra:\n      Math.cos(yAngle - currentAngle / 2) * ((lineWidth / 2) * (1 / Math.sin(currentAngle / 2))) - lineWidth / 2 || 0,\n  };\n  return extra;\n}\n\nexport default function (shape: IShape): SimpleBBox {\n  const attrs = shape.attr();\n  const { path, stroke } = attrs;\n  const lineWidth = stroke ? attrs.lineWidth : 0; // 只有有 stroke 时，lineWidth 才生效\n  const segments = shape.get('segments') || path2Segments(path);\n  const { x, y, width, height } = getPathBox(segments, lineWidth);\n  let bbox = {\n    minX: x,\n    minY: y,\n    maxX: x + width,\n    maxY: y + height,\n  };\n  bbox = mergeArrowBBox(shape, bbox);\n  return {\n    x: bbox.minX,\n    y: bbox.minY,\n    width: bbox.maxX - bbox.minX,\n    height: bbox.maxY - bbox.minY,\n  };\n}\n","import { register, getMethod } from './register';\nimport rect from './rect';\nimport circle from './circle';\nimport polyline from './polyline';\nimport polygon from './polygon';\nimport text from './text';\nimport path from './path';\nimport line from './line';\nimport ellipse from './ellipse';\n\nregister('rect', rect);\nregister('image', rect); // image 使用 rect 的包围盒计算\nregister('circle', circle);\nregister('marker', circle); // marker 使用 circle 的计算方案\nregister('polyline', polyline);\nregister('polygon', polygon);\nregister('text', text);\nregister('path', path);\nregister('line', line);\nregister('ellipse', ellipse);\n\nexport { getMethod as getBBoxMethod, register as registerBBox };\n","import { Util } from '@antv/g-math';\nimport { SimpleBBox } from '../types';\nimport { IShape } from '../interfaces';\nimport { mergeArrowBBox } from './util';\n\nexport default function (shape: IShape): SimpleBBox {\n  const attrs = shape.attr();\n  const { points } = attrs;\n  const xArr = [];\n  const yArr = [];\n  for (let i = 0; i < points.length; i++) {\n    const point = points[i];\n    xArr.push(point[0]);\n    yArr.push(point[1]);\n  }\n  const { x, y, width, height } = Util.getBBoxByArray(xArr, yArr);\n  let bbox = {\n    minX: x,\n    minY: y,\n    maxX: x + width,\n    maxY: y + height,\n  };\n  bbox = mergeArrowBBox(shape, bbox);\n  return {\n    x: bbox.minX,\n    y: bbox.minY,\n    width: bbox.maxX - bbox.minX,\n    height: bbox.maxY - bbox.minY,\n  };\n}\n","import { Util } from '@antv/g-math';\nimport { SimpleBBox } from '../types';\nimport { IShape } from '../interfaces';\n\nexport default function (shape: IShape): SimpleBBox {\n  const attrs = shape.attr();\n  const { points } = attrs;\n  const xArr = [];\n  const yArr = [];\n  for (let i = 0; i < points.length; i++) {\n    const point = points[i];\n    xArr.push(point[0]);\n    yArr.push(point[1]);\n  }\n  return Util.getBBoxByArray(xArr, yArr);\n}\n","import { SimpleBBox } from '../types';\nimport { IShape } from '../interfaces';\nimport { getTextWidth, getTextHeight, assembleFont } from '../util/text';\n\nexport default function (shape: IShape): SimpleBBox {\n  const attrs = shape.attr();\n  const { x, y, text, fontSize, lineHeight } = attrs;\n  let font = attrs.font;\n  if (!font) {\n    // 如果未组装 font\n    font = assembleFont(attrs);\n  }\n  const width = getTextWidth(text, font);\n  let bbox;\n  if (!width) {\n    // 如果width不存在，四点共其实点\n    bbox = {\n      x,\n      y,\n      width: 0,\n      height: 0,\n    };\n  } else {\n    const { textAlign, textBaseline } = attrs;\n    const height = getTextHeight(text, fontSize, lineHeight); // attrs.height\n    // 默认左右对齐：left, 默认上下对齐 bottom\n    const point = {\n      x,\n      y: y - height,\n    };\n    if (textAlign) {\n      if (textAlign === 'end' || textAlign === 'right') {\n        point.x -= width;\n      } else if (textAlign === 'center') {\n        point.x -= width / 2;\n      }\n    }\n    if (textBaseline) {\n      if (textBaseline === 'top') {\n        point.y += height;\n      } else if (textBaseline === 'middle') {\n        point.y += height / 2;\n      }\n    }\n\n    bbox = {\n      x: point.x,\n      y: point.y,\n      width: width,\n      height: height,\n    };\n  }\n  return bbox;\n}\n","import { SimpleBBox } from '../types';\nimport { IShape } from '../interfaces';\nimport { mergeArrowBBox } from './util';\n\nexport default function (shape: IShape): SimpleBBox {\n  const attrs = shape.attr();\n  const { x1, y1, x2, y2 } = attrs;\n  const minX = Math.min(x1, x2);\n  const maxX = Math.max(x1, x2);\n  const minY = Math.min(y1, y2);\n  const maxY = Math.max(y1, y2);\n  let bbox = {\n    minX,\n    maxX,\n    minY,\n    maxY,\n  };\n  bbox = mergeArrowBBox(shape, bbox);\n  return {\n    x: bbox.minX,\n    y: bbox.minY,\n    width: bbox.maxX - bbox.minX,\n    height: bbox.maxY - bbox.minY,\n  };\n}\n","import { SimpleBBox } from '../types';\nimport { IShape } from '../interfaces';\n\nexport default function (shape: IShape): SimpleBBox {\n  const attrs = shape.attr();\n  const { x, y, rx, ry } = attrs;\n  return {\n    x: x - rx,\n    y: y - ry,\n    width: rx * 2,\n    height: ry * 2,\n  };\n}\n","/**\n * @fileoverview 事件处理器\n * @author dxq613@gmail.com\n */\nimport GraphEvent from './graph-event';\nimport { ICanvas, IShape } from '../interfaces';\nimport { each, isParent } from '../util/util';\nconst CLICK_OFFSET = 40;\nconst LEFT_BTN_CODE = 0;\nconst DELEGATION_SPLIT = ':';\n\nconst EVENTS = [\n  'mousedown',\n  'mouseup',\n  'dblclick',\n  'mouseout',\n  'mouseover',\n  'mousemove',\n  'mouseleave',\n  'mouseenter',\n  'touchstart',\n  'touchmove',\n  'touchend',\n  'dragenter',\n  'dragover',\n  'dragleave',\n  'drop',\n  'contextmenu',\n  'mousewheel',\n];\n\n// 是否有委托事件监听\nfunction hasDelegation(events, type) {\n  for (const key in events) {\n    if (events.hasOwnProperty(key) && key.indexOf(DELEGATION_SPLIT + type) >= 0) {\n      return true;\n    }\n  }\n  return false;\n}\n\n// 触发目标事件，目标只能是 shape 或 canvas\nfunction emitTargetEvent(target, type, eventObj) {\n  eventObj.name = type;\n  eventObj.target = target;\n  eventObj.currentTarget = target;\n  eventObj.delegateTarget = target;\n  target.emit(type, eventObj);\n}\n\n// 事件冒泡, enter 和 leave 需要对 fromShape 和 toShape 进行判同\nfunction bubbleEvent(container, type, eventObj) {\n  if (eventObj.bubbles) {\n    let relativeShape;\n    let isOverEvent = false;\n    if (type === 'mouseenter') {\n      relativeShape = eventObj.fromShape;\n      isOverEvent = true;\n    } else if (type === 'mouseleave') {\n      isOverEvent = true;\n      relativeShape = eventObj.toShape;\n    }\n    // canvas 上的 mouseenter， mouseleave 事件，仅当进入或者移出 canvas 时触发\n    if (container.isCanvas() && isOverEvent) {\n      return;\n    }\n    // 如果相关图形同当前图形在同一个容器内，不触发事件\n    if (relativeShape && isParent(container, relativeShape)) {\n      // 阻止继续向上冒泡\n      eventObj.bubbles = false;\n      return;\n    }\n    // 事件名称可能在委托过程中被修改，因此事件冒泡时需要重新设置事件名称\n    eventObj.name = type;\n    eventObj.currentTarget = container;\n    eventObj.delegateTarget = container;\n    container.emit(type, eventObj);\n  }\n}\n\nclass EventController {\n  // 画布容器\n  private canvas: ICanvas;\n  // 正在被拖拽的图形\n  private draggingShape: IShape = null;\n  private dragging: boolean = false;\n  // 当前鼠标/touch所在位置的图形\n  private currentShape: IShape = null;\n  private mousedownShape: IShape = null;\n  private mousedownPoint = null;\n  private mousedownTimeStamp;\n\n  constructor(cfg) {\n    this.canvas = cfg.canvas;\n  }\n\n  init() {\n    this._bindEvents();\n  }\n\n  // 注册事件\n  _bindEvents() {\n    const el = this.canvas.get('el');\n    each(EVENTS, (eventName) => {\n      el.addEventListener(eventName, this._eventCallback);\n    });\n\n    if (document) {\n      // 处理移动到外面没有触发 shape mouse leave 的事件\n      // 处理拖拽到外部的问题\n      document.addEventListener('mousemove', this._onDocumentMove);\n      // 处理拖拽过程中在外部释放鼠标的问题\n      document.addEventListener('mouseup', this._onDocumentMouseUp);\n    }\n  }\n\n  // 清理事件\n  _clearEvents() {\n    const el = this.canvas.get('el');\n    each(EVENTS, (eventName) => {\n      el.removeEventListener(eventName, this._eventCallback);\n    });\n    if (document) {\n      document.removeEventListener('mousemove', this._onDocumentMove);\n      document.removeEventListener('mouseup', this._onDocumentMouseUp);\n    }\n  }\n\n  _getEventObj(type, event, point, target, fromShape, toShape) {\n    const eventObj = new GraphEvent(type, event);\n    eventObj.fromShape = fromShape;\n    eventObj.toShape = toShape;\n    eventObj.x = point.x;\n    eventObj.y = point.y;\n    eventObj.clientX = point.clientX;\n    eventObj.clientY = point.clientY;\n\n    eventObj.propagationPath.push(target);\n    // 事件的x,y应该是基于画布左上角的，与canvas的matrix无关\n    return eventObj;\n  }\n\n  // 统一处理所有的回调\n  _eventCallback = (ev) => {\n    const type = ev.type;\n    this._triggerEvent(type, ev);\n  };\n\n  // 根据点获取图形，提取成独立方法，便于后续优化\n  _getShape(point, ev: Event) {\n    return this.canvas.getShape(point.x, point.y, ev);\n  }\n  // 获取事件的当前点的信息\n  _getPointInfo(ev) {\n    const canvas = this.canvas;\n    const clientPoint = canvas.getClientByEvent(ev);\n    const point = canvas.getPointByEvent(ev);\n    return {\n      x: point.x,\n      y: point.y,\n      clientX: clientPoint.x,\n      clientY: clientPoint.y,\n    };\n  }\n\n  // 触发事件\n  _triggerEvent(type, ev) {\n    const pointInfo = this._getPointInfo(ev);\n    // 每次都获取图形有一定成本，后期可以考虑进行缓存策略\n    const shape = this._getShape(pointInfo, ev);\n    const method = this[`_on${type}`];\n    let leaveCanvas = false;\n    if (method) {\n      method.call(this, pointInfo, shape, ev);\n    } else {\n      const preShape = this.currentShape;\n      // 如果进入、移出画布时存在图形，则要分别触发事件\n      if (type === 'mouseenter' || type === 'dragenter' || type === 'mouseover') {\n        this._emitEvent(type, ev, pointInfo, null, null, shape); // 先进入画布\n        if (shape) {\n          this._emitEvent(type, ev, pointInfo, shape, null, shape); // 再触发图形的事件\n        }\n        if (type === 'mouseenter' && this.draggingShape) {\n          // 如果正在拖拽图形, 则触发 dragleave\n          this._emitEvent('dragenter', ev, pointInfo, null);\n        }\n      } else if (type === 'mouseleave' || type === 'dragleave' || type === 'mouseout') {\n        leaveCanvas = true;\n        if (preShape) {\n          this._emitEvent(type, ev, pointInfo, preShape, preShape, null); // 先触发图形的事件\n        }\n        this._emitEvent(type, ev, pointInfo, null, preShape, null); // 再触发离开画布事件\n        if (type === 'mouseleave' && this.draggingShape) {\n          this._emitEvent('dragleave', ev, pointInfo, null);\n        }\n      } else {\n        this._emitEvent(type, ev, pointInfo, shape, null, null); // 一般事件中不需要考虑 from, to\n      }\n    }\n    if (!leaveCanvas) {\n      this.currentShape = shape;\n    }\n    // 当鼠标从画布移动到 shape 或者从 preShape 移动到 shape 时，应用 shape 上的鼠标样式\n    if (shape && !shape.get('destroyed')) {\n      const canvas = this.canvas;\n      const el = canvas.get('el');\n      el.style.cursor = shape.attr('cursor') || canvas.get('cursor');\n    }\n  }\n\n  // 在 document 处理拖拽到画布外的事件，处理从图形上移除画布未被捕捉的问题\n  _onDocumentMove = (ev: Event) => {\n    const canvas = this.canvas;\n    const el = canvas.get('el');\n    if (el !== ev.target) {\n      // 不在 canvas 上移动\n      if (this.dragging || this.currentShape) {\n        const pointInfo = this._getPointInfo(ev);\n        // 还在拖拽过程中\n        if (this.dragging) {\n          this._emitEvent('drag', ev, pointInfo, this.draggingShape);\n        }\n        // 说明从某个图形直接移动到了画布外面，\n        // 修复了 mouseleave 的 bug 后不再出现这种情况\n        // if (this.currentShape) {\n        //   this._emitEvent('mouseleave', ev, pointInfo, this.currentShape, this.currentShape, null);\n        //   this.currentShape = null;\n        // }\n      }\n    }\n  };\n  // 在 document 上处理拖拽到外面，释放鼠标时触发 dragend\n  _onDocumentMouseUp = (ev) => {\n    const canvas = this.canvas;\n    const el = canvas.get('el');\n    if (el !== ev.target) {\n      // 不在 canvas 上移动\n      if (this.dragging) {\n        const pointInfo = this._getPointInfo(ev);\n        if (this.draggingShape) {\n          // 如果存在拖拽的图形，则也触发 drop 事件\n          this._emitEvent('drop', ev, pointInfo, null);\n        }\n        this._emitEvent('dragend', ev, pointInfo, this.draggingShape);\n        this._afterDrag(this.draggingShape, pointInfo, ev);\n      }\n    }\n  };\n\n  // 记录下点击的位置、图形，便于拖拽事件、click 事件的判定\n  _onmousedown(pointInfo, shape, event) {\n    // 只有鼠标左键的 mousedown 事件才会设置 mousedownShape 等属性，避免鼠标右键的 mousedown 事件引起其他事件发生\n    if (event.button === LEFT_BTN_CODE) {\n      this.mousedownShape = shape;\n      this.mousedownPoint = pointInfo;\n      this.mousedownTimeStamp = event.timeStamp;\n    }\n    this._emitEvent('mousedown', event, pointInfo, shape, null, null); // mousedown 不考虑fromShape, toShape\n  }\n\n  // mouseleave 和 mouseenter 都是成对存在的\n  // mouseenter 和 mouseover 同时触发\n  _emitMouseoverEvents(event, pointInfo, fromShape, toShape) {\n    const el = this.canvas.get('el');\n    if (fromShape !== toShape) {\n      if (fromShape) {\n        this._emitEvent('mouseout', event, pointInfo, fromShape, fromShape, toShape);\n        this._emitEvent('mouseleave', event, pointInfo, fromShape, fromShape, toShape);\n        // 当鼠标从 fromShape 移动到画布上时，重置鼠标样式\n        if (!toShape || toShape.get('destroyed')) {\n          el.style.cursor = this.canvas.get('cursor');\n        }\n      }\n      if (toShape) {\n        this._emitEvent('mouseover', event, pointInfo, toShape, fromShape, toShape);\n        this._emitEvent('mouseenter', event, pointInfo, toShape, fromShape, toShape);\n      }\n    }\n  }\n  // dragover 不等同于 mouseover，而等同于 mousemove\n  _emitDragoverEvents(event, pointInfo, fromShape, toShape, isCanvasEmit) {\n    if (toShape) {\n      if (toShape !== fromShape) {\n        if (fromShape) {\n          this._emitEvent('dragleave', event, pointInfo, fromShape, fromShape, toShape);\n        }\n        this._emitEvent('dragenter', event, pointInfo, toShape, fromShape, toShape);\n      }\n      if (!isCanvasEmit) {\n        this._emitEvent('dragover', event, pointInfo, toShape);\n      }\n    } else if (fromShape) {\n      // TODO: 此处判断有问题，当 drag 图形时，也会触发一次 dragleave 事件，因为此时 toShape 为 null，这不是所期望的\n      // 经过空白区域\n      this._emitEvent('dragleave', event, pointInfo, fromShape, fromShape, toShape);\n    }\n\n    if (isCanvasEmit) {\n      this._emitEvent('dragover', event, pointInfo, toShape);\n    }\n  }\n\n  // drag 完成后，需要做一些清理工作\n  _afterDrag(draggingShape, pointInfo, event) {\n    if (draggingShape) {\n      draggingShape.set('capture', true); // 恢复可以拾取\n      this.draggingShape = null;\n    }\n    this.dragging = false;\n    // drag 完成后，有可能 draggingShape 已经移动到了当前位置，所以不能直接取当前图形\n    const shape = this._getShape(pointInfo, event);\n    // 拖拽完成后，进行 enter，leave 的判定\n    if (shape !== draggingShape) {\n      this._emitMouseoverEvents(event, pointInfo, draggingShape, shape);\n    }\n    this.currentShape = shape; // 更新当前 shape，如果不处理当前图形的 mouseleave 事件可能会出问题\n  }\n  // 按键抬起时，会终止拖拽、触发点击\n  _onmouseup(pointInfo, shape, event) {\n    // eevent.button === 0 表示鼠标左键事件，此处加上判断主要是为了避免右键鼠标会触发 mouseup 和 click 事件\n    // ref: https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button\n    if (event.button === LEFT_BTN_CODE) {\n      const draggingShape = this.draggingShape;\n      if (this.dragging) {\n        // 存在可以拖拽的图形，同时拖拽到其他图形上时触发 drag 事件\n        if (draggingShape) {\n          this._emitEvent('drop', event, pointInfo, shape);\n        }\n        this._emitEvent('dragend', event, pointInfo, draggingShape);\n        this._afterDrag(draggingShape, pointInfo, event);\n      } else {\n        this._emitEvent('mouseup', event, pointInfo, shape); // 先触发 mouseup 再触发 click\n        if (shape === this.mousedownShape) {\n          this._emitEvent('click', event, pointInfo, shape);\n        }\n        this.mousedownShape = null;\n        this.mousedownPoint = null;\n      }\n    }\n  }\n\n  // 当触发浏览器的 dragover 事件时，不会再触发 mousemove ，所以这时候的 dragenter, dragleave 事件需要重新处理\n  _ondragover(pointInfo, shape, event) {\n    event.preventDefault(); // 如果不对 dragover 进行 preventDefault，则不会在 canvas 上触发 drop 事件\n    const preShape = this.currentShape;\n    this._emitDragoverEvents(event, pointInfo, preShape, shape, true);\n  }\n\n  // 大量的图形事件，都通过 mousemove 模拟\n  _onmousemove(pointInfo, shape, event) {\n    const canvas = this.canvas;\n    const preShape = this.currentShape;\n    let draggingShape = this.draggingShape;\n    // 正在拖拽时\n    if (this.dragging) {\n      // 正在拖拽中\n      if (draggingShape) {\n        // 如果拖拽了 shape 会触发 dragenter, dragleave, dragover 和 drag 事件\n        this._emitDragoverEvents(event, pointInfo, preShape, shape, false);\n      }\n      // 如果存在 draggingShape 则会在 draggingShape 上触发 drag 事件，冒泡到 canvas 上\n      // 否则在 canvas 上触发 drag 事件\n      this._emitEvent('drag', event, pointInfo, draggingShape);\n    } else {\n      const mousedownPoint = this.mousedownPoint;\n      if (mousedownPoint) {\n        // 当鼠标点击下去，同时移动时，进行 drag 判定\n        const mousedownShape = this.mousedownShape;\n        const now = event.timeStamp;\n        const timeWindow = now - this.mousedownTimeStamp;\n        const dx = mousedownPoint.clientX - pointInfo.clientX;\n        const dy = mousedownPoint.clientY - pointInfo.clientY;\n        const dist = dx * dx + dy * dy;\n        if (timeWindow > 120 || dist > CLICK_OFFSET) {\n          if (mousedownShape && mousedownShape.get('draggable')) {\n            // 设置了 draggable 的 shape 才能触发 drag 相关的事件\n            draggingShape = this.mousedownShape; // 拖动鼠标点下时的 shape\n            draggingShape.set('capture', false); // 禁止继续拾取，否则无法进行 dragover,dragenter,dragleave,drop的判定\n            this.draggingShape = draggingShape;\n            this.dragging = true;\n            this._emitEvent('dragstart', event, pointInfo, draggingShape);\n            // 清理按下鼠标时缓存的值\n            this.mousedownShape = null;\n            this.mousedownPoint = null;\n          } else if (!mousedownShape && canvas.get('draggable')) {\n            // 设置了 draggable 的 canvas 才能触发 drag 相关的事件\n            this.dragging = true;\n            this._emitEvent('dragstart', event, pointInfo, null);\n            // 清理按下鼠标时缓存的值\n            this.mousedownShape = null;\n            this.mousedownPoint = null;\n          } else {\n            this._emitMouseoverEvents(event, pointInfo, preShape, shape);\n            this._emitEvent('mousemove', event, pointInfo, shape);\n          }\n        } else {\n          this._emitMouseoverEvents(event, pointInfo, preShape, shape);\n          this._emitEvent('mousemove', event, pointInfo, shape);\n        }\n      } else {\n        // 没有按键按下时，则直接触发 mouse over 相关的各种事件\n        this._emitMouseoverEvents(event, pointInfo, preShape, shape);\n        // 始终触发移动\n        this._emitEvent('mousemove', event, pointInfo, shape);\n      }\n    }\n  }\n\n  // 触发事件\n  _emitEvent(type, event, pointInfo, shape, fromShape?, toShape?) {\n    const eventObj = this._getEventObj(type, event, pointInfo, shape, fromShape, toShape);\n    // 存在 shape 触发，则进行冒泡处理\n    if (shape) {\n      eventObj.shape = shape;\n      // 触发 shape 上的事件\n      emitTargetEvent(shape, type, eventObj);\n      let parent = shape.getParent();\n      // 执行冒泡\n      while (parent) {\n        // 委托事件要先触发\n        parent.emitDelegation(type, eventObj);\n        // 事件冒泡停止，不能妨碍委托事件\n        if (!eventObj.propagationStopped) {\n          bubbleEvent(parent, type, eventObj);\n        }\n        eventObj.propagationPath.push(parent);\n        parent = parent.getParent();\n      }\n    } else {\n      // 如果没有 shape 直接在 canvas 上触发\n      const canvas = this.canvas;\n      // 直接触发 canvas 上的事件\n      emitTargetEvent(canvas, type, eventObj);\n    }\n  }\n\n  destroy() {\n    // 清理事件\n    this._clearEvents();\n    // 清理缓存的对象\n    this.canvas = null;\n    this.currentShape = null;\n    this.draggingShape = null;\n    this.mousedownPoint = null;\n    this.mousedownShape = null;\n    this.mousedownTimeStamp = null;\n  }\n}\n\nexport default EventController;\n","import { IShape } from '../interfaces';\nimport { LooseObject } from '../types';\n\nclass GraphEvent {\n  /**\n   * 事件类型\n   * @type {string}\n   */\n  type: string;\n  /**\n   * 事件名称\n   * @type {string}\n   */\n  name: string;\n  /**\n   * 画布上的位置 x\n   * @type {number}\n   */\n  x: number;\n  /**\n   * 画布上的位置 y\n   * @type {number}\n   */\n  y: number;\n  /**\n   * 窗口上的位置 x\n   * @type {number}\n   */\n  clientX: number;\n  /**\n   * 窗口上的位置 y\n   * @type {number}\n   */\n  clientY: number;\n  /**\n   * 是否允许冒泡\n   * @type {boolean}\n   */\n  bubbles: boolean = true;\n  /**\n   * 触发对象\n   * @type {object}\n   */\n  target: LooseObject = null;\n  /**\n   * 监听对象\n   * @type {object}\n   */\n  currentTarget: LooseObject = null;\n  /**\n   * 委托对象\n   * @type {object}\n   */\n  delegateTarget: LooseObject = null;\n  /**\n   * 委托事件监听对象的代理对象，即 ev.delegateObject = ev.currentTarget.get('delegateObject')\n   * @type {object}\n   */\n  delegateObject: object = null;\n  /**\n   * 是否阻止了原生事件\n   * @type {boolean}\n   */\n  defaultPrevented: boolean = false;\n  /**\n   * 是否阻止传播（向上冒泡）\n   * @type {boolean}\n   */\n  propagationStopped: boolean = false;\n  /**\n   * 触发事件的图形\n   * @type {IShape}\n   */\n  shape: IShape = null;\n  /**\n   * 开始触发事件的图形\n   * @type {IShape}\n   */\n  fromShape: IShape = null;\n  /**\n   * 事件结束时的触发图形\n   * @type {IShape}\n   */\n  toShape: IShape = null;\n\n  /**\n   * 触发时的时间\n   * @type {number}\n   */\n  timeStamp: number;\n\n  /**\n   * 触发时的对象\n   * @type {object}\n   */\n  originalEvent: Event;\n\n  // 触发事件的路径\n  propagationPath: any[] = [];\n\n  constructor(type, event) {\n    this.type = type;\n    this.name = type;\n    this.originalEvent = event;\n    this.timeStamp = event.timeStamp;\n  }\n\n  /**\n   * 阻止浏览器默认的行为\n   */\n  preventDefault() {\n    this.defaultPrevented = true;\n    if (this.originalEvent.preventDefault) {\n      this.originalEvent.preventDefault();\n    }\n  }\n\n  /**\n   * 阻止冒泡\n   */\n  stopPropagation() {\n    this.propagationStopped = true;\n  }\n\n  toString() {\n    const type = this.type;\n    return `[Event (type=${type})]`;\n  }\n\n  save() {}\n\n  restore() {}\n}\n\nexport default GraphEvent;\n","/**\n * @fileoverview G 的基础接口定义和所有的抽象类\n * @author dxq613@gmail.com\n */\n\nimport * as PathUtil from './util/path';\n\nexport * from './types';\nexport * from './interfaces';\nexport { default as Event } from './event/graph-event';\nexport { default as Base } from './abstract/base';\nexport { default as AbstractCanvas } from './abstract/canvas';\nexport { default as AbstractGroup } from './abstract/group';\nexport { default as AbstractShape } from './abstract/shape';\nexport { PathUtil };\n\nexport { getBBoxMethod, registerBBox } from './bbox';\nexport { getTextHeight, assembleFont } from './util/text';\nexport { isAllowCapture } from './util/util';\nexport { multiplyVec2, invert } from './util/matrix';\nexport { getOffScreenContext } from './util/offscreen';\nexport { registerEasing } from './animate/register';\n\nexport const version = '0.5.11';\n","/**\n * @fileoverview 矩阵运算，本来是要引入 gl-matrix, 但是考虑到 g-mobile 对大小有限制，同时 g-webgl 使用的 matrix 不一致\n * 所以，这里仅实现 2D 几个运算，上层自己引入 gl-matrix\n * @author dxq613@gmail.com\n */\n\n/**\n * 3阶矩阵相乘\n * @param {number[]} a 矩阵1\n * @param {number[]} b 矩阵2\n */\nexport function multiplyMatrix(a: number[], b: number[]) {\n  const out = [];\n  const a00 = a[0];\n  const a01 = a[1];\n  const a02 = a[2];\n\n  const a10 = a[3];\n  const a11 = a[4];\n  const a12 = a[5];\n  const a20 = a[6];\n  const a21 = a[7];\n  const a22 = a[8];\n\n  const b00 = b[0];\n  const b01 = b[1];\n  const b02 = b[2];\n  const b10 = b[3];\n  const b11 = b[4];\n  const b12 = b[5];\n  const b20 = b[6];\n  const b21 = b[7];\n  const b22 = b[8];\n\n  out[0] = b00 * a00 + b01 * a10 + b02 * a20;\n  out[1] = b00 * a01 + b01 * a11 + b02 * a21;\n  out[2] = b00 * a02 + b01 * a12 + b02 * a22;\n\n  out[3] = b10 * a00 + b11 * a10 + b12 * a20;\n  out[4] = b10 * a01 + b11 * a11 + b12 * a21;\n  out[5] = b10 * a02 + b11 * a12 + b12 * a22;\n\n  out[6] = b20 * a00 + b21 * a10 + b22 * a20;\n  out[7] = b20 * a01 + b21 * a11 + b22 * a21;\n  out[8] = b20 * a02 + b21 * a12 + b22 * a22;\n  return out;\n}\n\n/**\n * 3阶矩阵同2阶向量相乘\n * @param {number[]} m 矩阵\n * @param {number[]} v 二阶向量\n */\nexport function multiplyVec2(m: number[], v: number[]) {\n  const out = [];\n  const x = v[0];\n  const y = v[1];\n  out[0] = m[0] * x + m[3] * y + m[6];\n  out[1] = m[1] * x + m[4] * y + m[7];\n  return out;\n}\n\n/**\n * 矩阵的逆\n * @param {number[]} a 矩阵\n */\nexport function invert(a: number[]) {\n  const out = [];\n  const a00 = a[0];\n  const a01 = a[1];\n  const a02 = a[2];\n  const a10 = a[3];\n  const a11 = a[4];\n  const a12 = a[5];\n  const a20 = a[6];\n  const a21 = a[7];\n  const a22 = a[8];\n\n  const b01 = a22 * a11 - a12 * a21;\n  const b11 = -a22 * a10 + a12 * a20;\n  const b21 = a21 * a10 - a11 * a20;\n\n  // Calculate the determinant\n  let det = a00 * b01 + a01 * b11 + a02 * b21;\n\n  if (!det) {\n    return null;\n  }\n  det = 1.0 / det;\n\n  out[0] = b01 * det;\n  out[1] = (-a22 * a01 + a02 * a21) * det;\n  out[2] = (a12 * a01 - a02 * a11) * det;\n  out[3] = b11 * det;\n  out[4] = (a22 * a00 - a02 * a20) * det;\n  out[5] = (-a12 * a00 + a02 * a10) * det;\n  out[6] = b21 * det;\n  out[7] = (-a21 * a00 + a01 * a20) * det;\n  out[8] = (a11 * a00 - a01 * a10) * det;\n  return out;\n}\n","// 全局设置一个唯一离屏的 ctx，用于计算 isPointInPath\nlet offScreenCtx = null;\nexport function getOffScreenContext() {\n  if (!offScreenCtx) {\n    const canvas = document.createElement('canvas');\n    canvas.width = 1;\n    canvas.height = 1;\n    offScreenCtx = canvas.getContext('2d');\n  }\n  return offScreenCtx;\n}\n","import { isNil, each, isString } from './util';\nimport { getOffScreenContext } from './offscreen';\nimport { ShapeAttrs } from '../types';\n\n/**\n * 获取文本的高度\n * @param text 文本\n * @param fontSize 字体大小\n * @param lineHeight 行高，可以为空\n */\nexport function getTextHeight(text: string, fontSize: number, lineHeight?: number): number {\n  let lineCount = 1;\n  if (isString(text)) {\n    lineCount = text.split('\\n').length;\n  }\n  if (lineCount > 1) {\n    const spaceingY = getLineSpaceing(fontSize, lineHeight);\n    return fontSize * lineCount + spaceingY * (lineCount - 1);\n  }\n  return fontSize;\n}\n\n/**\n * 获取行间距如果文本多行，需要获取文本间距\n * @param fontSize 字体大小\n * @param lineHeight 行高\n */\nexport function getLineSpaceing(fontSize: number, lineHeight?: number): number {\n  return lineHeight ? lineHeight - fontSize : fontSize * 0.14;\n}\n\n/**\n * 字体宽度\n * @param text 文本\n * @param font 字体\n */\nexport function getTextWidth(text: string, font: string) {\n  const context = getOffScreenContext(); // 获取离屏的 ctx 进行计算\n  let width = 0;\n  // null 或者 undefined 时，宽度为 0\n  if (isNil(text) || text === '') {\n    return width;\n  }\n  context.save();\n  context.font = font;\n  if (isString(text) && text.includes('\\n')) {\n    const textArr = text.split('\\n');\n    each(textArr, (subText) => {\n      const measureWidth = context.measureText(subText).width;\n      if (width < measureWidth) {\n        width = measureWidth;\n      }\n    });\n  } else {\n    width = context.measureText(text).width;\n  }\n  context.restore();\n  return width;\n}\n\nexport function assembleFont(attrs: ShapeAttrs) {\n  const { fontSize, fontFamily, fontWeight, fontStyle, fontVariant } = attrs;\n  return [fontStyle, fontVariant, fontWeight, `${fontSize}px`, fontFamily].join(' ').trim();\n}\n","import { IBase } from '../interfaces';\nexport function removeFromArray(arr: any[], obj: any) {\n  const index = arr.indexOf(obj);\n  if (index !== -1) {\n    arr.splice(index, 1);\n  }\n}\n\nexport const isBrowser = typeof window !== 'undefined' && typeof window.document !== 'undefined';\nexport { isNil, isFunction, isString, isObject, isArray, mix, each, upperFirst } from '@antv/util';\n\n// 是否元素的父容器\nexport function isParent(container, shape) {\n  // 所有 shape 都是 canvas 的子元素\n  if (container.isCanvas()) {\n    return true;\n  }\n  let parent = shape.getParent();\n  let isParent = false;\n  while (parent) {\n    if (parent === container) {\n      isParent = true;\n      break;\n    }\n    parent = parent.getParent();\n  }\n  return isParent;\n}\n\nexport function isAllowCapture(element: IBase): boolean {\n  // @ts-ignore\n  return element.cfg.visible && element.cfg.capture;\n}\n"],"names":["EASING_MAP","getEasing","type","toLowerCase","d3Ease","registerEasing","easeFn","IDENTITY_MATRIX","update","shape","animation","elapsed","ratio","startTime","_paused","duration","easing","delay","repeat","onFrame","attr","toAttrs","attrs","cProps","fromAttrs","destroyed","interf","val","k","isEqual","toPath","fromPath","length","PathUtil","path","pathFormatted","i","toPathPoint","fromPathPoint","cPathPoint","j","isNumber","interpolate","push","currentMatrix","interpolateArray","matrixFn","includes","test","isFunction","_update","canvas","animators","current","timer","this","Timeline","animations","d3Timer","_this","removeAnimator","isAnimatePaused","get","splice","callback","draw","index","stop","toEnd","forEach","animator","stopAnimate","cache","Map","register","method","set","getMethod","x","y","width","height","r","mergeBBox","bbox1","bbox2","minX","Math","min","minY","maxX","max","maxY","mergeArrowBBox","bbox","startArrowShape","endArrowShape","getCanvasBBox","getExtraFromSegmentWithAngle","segment","lineWidth","prePoint","currentPoint","nextPoint","currentAndPre","pow","currentAndNext","preAndNext","currentAngle","acos","sqrt","sin","isNumberEqual","xExtra","yExtra","xAngle","abs","atan2","yAngle","PI","cos","rect","circle","points","xArr","yArr","point","Util","text","fontSize","lineHeight","font","assembleFont","getTextWidth","textAlign","textBaseline","getTextHeight","segments","segmentsWithAngle","params","box","command","QuadUtil","CubicUtil","arcParams","EllipseArcUtil","cx","cy","rx","ry","xRotation","startAngle","endAngle","filter","item","Number","isNaN","Infinity","getPathBox","path2Segments","x1","y1","x2","y2","EVENTS","emitTargetEvent","target","eventObj","name","currentTarget","delegateTarget","emit","bubbleEvent","container","bubbles","relativeShape","isOverEvent","fromShape","toShape","isCanvas","isParent","cfg","draggingShape","dragging","currentShape","mousedownShape","mousedownPoint","_eventCallback","ev","_triggerEvent","_onDocumentMove","pointInfo","_getPointInfo","_emitEvent","_onDocumentMouseUp","_afterDrag","EventController","_bindEvents","el","each","eventName","addEventListener","document","removeEventListener","event","GraphEvent","clientX","clientY","propagationPath","getShape","clientPoint","getClientByEvent","getPointByEvent","_getShape","leaveCanvas","call","preShape","style","cursor","button","mousedownTimeStamp","timeStamp","isCanvasEmit","_emitMouseoverEvents","preventDefault","_emitDragoverEvents","timeWindow","dx","dy","_getEventObj","parent_1","getParent","emitDelegation","propagationStopped","_clearEvents","delegateObject","defaultPrevented","originalEvent","version","multiplyMatrix","a","b","out","a00","a01","a02","a10","a11","a12","a20","a21","a22","b00","b01","b02","b10","b11","b12","b20","b21","b22","multiplyVec2","m","v","invert","det","offScreenCtx","getOffScreenContext","createElement","getContext","lineCount","isString","split","spaceingY","getLineSpaceing","context","isNil","save","textArr","subText","measureWidth","measureText","restore","fontFamily","fontWeight","join","trim","removeFromArray","arr","obj","indexOf","isBrowser","window","parent","isAllowCapture","element","visible","capture"],"sourceRoot":""}